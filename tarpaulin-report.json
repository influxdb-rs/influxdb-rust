{"files":[{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","benches","client.rs"],"content":"use chrono::{DateTime, Utc};\nuse influxdb::{Client, Error, InfluxDbWriteable, ReadQuery};\nuse std::sync::Arc;\nuse std::time::Instant;\nuse tokio::sync::mpsc::unbounded_channel;\nuse tokio::sync::Semaphore;\n\n#[derive(InfluxDbWriteable, Clone)]\nstruct WeatherReading {\n    time: DateTime<Utc>,\n    humidity: i32,\n    #[influxdb(tag)]\n    wind_direction: String,\n}\n\n#[tokio::main]\nasync fn main() {\n    let db_name = \"bench\";\n    let url = \"http://localhost:8086\";\n    let number_of_total_requests = 20000;\n    let concurrent_requests = 1000;\n\n    let client = Client::new(url, db_name);\n    let concurrency_limit = Arc::new(Semaphore::new(concurrent_requests));\n\n    prepare_influxdb(&client, db_name).await;\n    let measurements = generate_measurements(number_of_total_requests);\n    let (tx, mut rx) = unbounded_channel::<Result<String, Error>>();\n\n    let start = Instant::now();\n    for m in measurements {\n        let permit = concurrency_limit.clone().acquire_owned().await;\n        let client_task = client.clone();\n        let tx_task = tx.clone();\n        tokio::spawn(async move {\n            let res = client_task.query(&m.into_query(\"weather\")).await;\n            let _ = tx_task.send(res);\n            drop(permit);\n        });\n    }\n    drop(tx);\n\n    let mut successful_count = 0;\n    let mut error_count = 0;\n    while let Some(res) = rx.recv().await {\n        if res.is_err() {\n            error_count += 1;\n        } else {\n            successful_count += 1;\n        }\n    }\n\n    let end = Instant::now();\n\n    println!(\n        \"Throughput: {:.1} request/s\",\n        1000000.0 * successful_count as f64 / (end - start).as_micros() as f64\n    );\n    println!(\n        \"{} successful requests, {} errors\",\n        successful_count, error_count\n    );\n}\n\nasync fn prepare_influxdb(client: &Client, db_name: &str) {\n    let create_db_stmt = format!(\"CREATE DATABASE {}\", db_name);\n    client\n        .query(&ReadQuery::new(create_db_stmt))\n        .await\n        .expect(\"failed to create database\");\n}\n\nfn generate_measurements(n: u64) -> Vec<WeatherReading> {\n    (0..n)\n        .collect::<Vec<u64>>()\n        .iter_mut()\n        .map(|_| WeatherReading {\n            time: Utc::now(),\n            humidity: 30,\n            wind_direction: String::from(\"north\"),\n        })\n        .collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","client","mod.rs"],"content":"//! Client which can read and write data from InfluxDB.\n//!\n//! # Arguments\n//!\n//!  * `url`: The URL where InfluxDB is running (ex. `http://localhost:8086`).\n//!  * `database`: The Database against which queries and writes will be run.\n//!\n//! # Examples\n//!\n//! ```rust\n//! use influxdb::Client;\n//!\n//! let client = Client::new(\"http://localhost:8086\", \"test\");\n//!\n//! assert_eq!(client.database_name(), \"test\");\n//! ```\n\nuse futures_util::TryFutureExt;\nuse reqwest::{Client as HttpClient, RequestBuilder, Response as HttpResponse};\nuse std::collections::{BTreeMap, HashMap};\nuse std::fmt::{self, Debug, Formatter};\nuse std::sync::Arc;\n\nuse crate::query::QueryType;\nuse crate::{Error, Query};\n\n#[derive(Clone)]\n/// Internal Representation of a Client\npub struct Client {\n    pub(crate) url: Arc<String>,\n    pub(crate) parameters: Arc<HashMap<&'static str, String>>,\n    pub(crate) token: Option<String>,\n    pub(crate) client: HttpClient,\n}\n\nstruct RedactPassword<'a>(&'a HashMap<&'static str, String>);\n\nimpl<'a> Debug for RedactPassword<'a> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        let entries = self\n            .0\n            .iter()\n            .map(|(k, v)| match *k {\n                \"p\" => (*k, \"<redacted>\"),\n                _ => (*k, v.as_str()),\n            })\n            .collect::<BTreeMap<&'static str, &str>>();\n        f.debug_map().entries(entries).finish()\n    }\n}\n\nimpl Debug for Client {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Client\")\n            .field(\"url\", &self.url)\n            .field(\"parameters\", &RedactPassword(&self.parameters))\n            .finish_non_exhaustive()\n    }\n}\n\nimpl Client {\n    /// Instantiates a new [`Client`](crate::Client)\n    ///\n    /// # Arguments\n    ///\n    ///  * `url`: The URL where InfluxDB is running (ex. `http://localhost:8086`).\n    ///  * `database`: The Database against which queries and writes will be run.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use influxdb::Client;\n    ///\n    /// let _client = Client::new(\"http://localhost:8086\", \"test\");\n    /// ```\n    #[must_use = \"Creating a client is pointless unless you use it\"]\n    pub fn new<S1, S2>(url: S1, database: S2) -> Self\n    where\n        S1: Into<String>,\n        S2: Into<String>,\n    {\n        let mut parameters = HashMap::<&str, String>::new();\n        parameters.insert(\"db\", database.into());\n        Client {\n            url: Arc::new(url.into()),\n            parameters: Arc::new(parameters),\n            client: HttpClient::new(),\n            token: None,\n        }\n    }\n\n    /// Add authentication/authorization information to [`Client`](crate::Client)\n    ///\n    /// # Arguments\n    ///\n    /// * username: The Username for InfluxDB.\n    /// * password: The Password for the user.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use influxdb::Client;\n    ///\n    /// let _client = Client::new(\"http://localhost:9086\", \"test\").with_auth(\"admin\", \"password\");\n    /// ```\n    #[must_use = \"Creating a client is pointless unless you use it\"]\n    pub fn with_auth<S1, S2>(mut self, username: S1, password: S2) -> Self\n    where\n        S1: Into<String>,\n        S2: Into<String>,\n    {\n        let mut with_auth = self.parameters.as_ref().clone();\n        with_auth.insert(\"u\", username.into());\n        with_auth.insert(\"p\", password.into());\n        self.parameters = Arc::new(with_auth);\n        self\n    }\n\n    /// Replaces the HTTP Client\n    #[must_use = \"Creating a client is pointless unless you use it\"]\n    pub fn with_http_client(mut self, http_client: HttpClient) -> Self {\n        self.client = http_client;\n        self\n    }\n\n    /// Add authorization token to [`Client`](crate::Client)\n    ///\n    /// This is designed for influxdb 2.0's backward-compatible API which\n    /// requires authorization by default. You can create such token from\n    /// console of influxdb 2.0 .\n    pub fn with_token<S>(mut self, token: S) -> Self\n    where\n        S: Into<String>,\n    {\n        self.token = Some(token.into());\n        self\n    }\n\n    /// Returns the name of the database the client is using\n    pub fn database_name(&self) -> &str {\n        // safe to unwrap: we always set the database name in `Self::new`\n        self.parameters.get(\"db\").unwrap()\n    }\n\n    /// Returns the URL of the InfluxDB installation the client is using\n    pub fn database_url(&self) -> &str {\n        &self.url\n    }\n\n    /// Pings the InfluxDB Server\n    ///\n    /// Returns a tuple of build type and version number\n    pub async fn ping(&self) -> Result<(String, String), Error> {\n        let url = &format!(\"{}/ping\", self.url);\n        let res = self\n            .client\n            .get(url)\n            .send()\n            .await\n            .map_err(|err| Error::ProtocolError {\n                error: err.to_string(),\n            })?;\n\n        const BUILD_HEADER: &str = \"X-Influxdb-Build\";\n        const VERSION_HEADER: &str = \"X-Influxdb-Version\";\n\n        let (build, version) = {\n            let hdrs = res.headers();\n            (\n                hdrs.get(BUILD_HEADER).and_then(|value| value.to_str().ok()),\n                hdrs.get(VERSION_HEADER)\n                    .and_then(|value| value.to_str().ok()),\n            )\n        };\n\n        Ok((build.unwrap().to_owned(), version.unwrap().to_owned()))\n    }\n\n    /// Sends a [`ReadQuery`](crate::ReadQuery) or [`WriteQuery`](crate::WriteQuery) to the InfluxDB Server.\n    ///\n    /// A version capable of parsing the returned string is available under the [serde_integration](crate::integrations::serde_integration)\n    ///\n    /// # Arguments\n    ///\n    ///  * `q`: Query of type [`ReadQuery`](crate::ReadQuery) or [`WriteQuery`](crate::WriteQuery)\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use influxdb::{Client, InfluxDbWriteable, Query, Timestamp};\n    /// use std::time::{SystemTime, UNIX_EPOCH};\n    ///\n    /// # #[tokio::main]\n    /// # async fn main() -> Result<(), influxdb::Error> {\n    /// let start = SystemTime::now();\n    /// let since_the_epoch = start\n    ///     .duration_since(UNIX_EPOCH)\n    ///     .expect(\"Time went backwards\")\n    ///     .as_millis();\n    ///\n    /// let client = Client::new(\"http://localhost:8086\", \"test\");\n    /// let query = Timestamp::Milliseconds(since_the_epoch)\n    ///     .try_into_query(\"weather\")\n    ///     .unwrap()\n    ///     .add_field(\"temperature\", 82);\n    /// let results = client.query(query).await?;\n    ///\n    /// # Ok(())\n    /// # }\n    /// ```\n    /// # Errors\n    ///\n    /// If the function can not finish the query,\n    /// a [`Error`] variant will be returned.\n    ///\n    /// [`Error`]: enum.Error.html\n    pub async fn query<Q>(&self, q: Q) -> Result<String, Error>\n    where\n        Q: Query,\n    {\n        let query = q.build().map_err(|err| Error::InvalidQueryError {\n            error: err.to_string(),\n        })?;\n\n        let mut parameters = self.parameters.as_ref().clone();\n        let request_builder = match q.get_type() {\n            QueryType::ReadQuery => {\n                let read_query = query.get();\n                let url = &format!(\"{}/query\", &self.url);\n                parameters.insert(\"q\", read_query.clone());\n\n                if read_query.contains(\"SELECT\") || read_query.contains(\"SHOW\") {\n                    self.client.get(url).query(&parameters)\n                } else {\n                    self.client.post(url).query(&parameters)\n                }\n            }\n            QueryType::WriteQuery(precision) => {\n                let url = &format!(\"{}/write\", &self.url);\n                let mut parameters = self.parameters.as_ref().clone();\n                parameters.insert(\"precision\", precision);\n\n                self.client.post(url).body(query.get()).query(&parameters)\n            }\n        };\n\n        let res = self\n            .auth_if_needed(request_builder)\n            .send()\n            .map_err(|err| Error::ConnectionError {\n                error: err.to_string(),\n            })\n            .await?;\n        check_status(&res)?;\n\n        let body = res.text();\n\n        let s = body.await.map_err(|_| Error::DeserializationError {\n            error: \"response could not be converted to UTF-8\".into(),\n        })?;\n\n        // todo: improve error parsing without serde\n        if s.contains(\"\\\"error\\\"\") || s.contains(\"\\\"Error\\\"\") {\n            return Err(Error::DatabaseError {\n                error: format!(\"influxdb error: {s:?}\"),\n            });\n        }\n\n        Ok(s)\n    }\n\n    fn auth_if_needed(&self, rb: RequestBuilder) -> RequestBuilder {\n        if let Some(ref token) = self.token {\n            rb.header(\"Authorization\", format!(\"Token {token}\"))\n        } else {\n            rb\n        }\n    }\n}\n\npub(crate) fn check_status(res: &HttpResponse) -> Result<(), Error> {\n    let status = res.status();\n    if !status.is_success() {\n        return Err(Error::ApiError(status.into()));\n    }\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Client;\n    use indoc::indoc;\n\n    #[test]\n    fn test_client_debug_redacted_password() {\n        let client = Client::new(\"https://localhost:8086\", \"db\").with_auth(\"user\", \"pass\");\n        let actual = format!(\"{client:#?}\");\n        let expected = indoc! { r#\"\n            Client {\n                url: \"https://localhost:8086\",\n                parameters: {\n                    \"db\": \"db\",\n                    \"p\": \"<redacted>\",\n                    \"u\": \"user\",\n                },\n                ..\n            }\n        \"# };\n        assert_eq!(actual.trim(), expected.trim());\n    }\n\n    #[test]\n    fn test_fn_database() {\n        let client = Client::new(\"http://localhost:8068\", \"database\");\n        assert_eq!(client.database_name(), \"database\");\n        assert_eq!(client.database_url(), \"http://localhost:8068\");\n    }\n\n    #[test]\n    fn test_with_auth() {\n        let client = Client::new(\"http://localhost:8068\", \"database\");\n        assert_eq!(client.parameters.len(), 1);\n        assert_eq!(client.parameters.get(\"db\").unwrap(), \"database\");\n\n        let with_auth = client.with_auth(\"username\", \"password\");\n        assert_eq!(with_auth.parameters.len(), 3);\n        assert_eq!(with_auth.parameters.get(\"db\").unwrap(), \"database\");\n        assert_eq!(with_auth.parameters.get(\"u\").unwrap(), \"username\");\n        assert_eq!(with_auth.parameters.get(\"p\").unwrap(), \"password\");\n\n        let client = Client::new(\"http://localhost:8068\", \"database\");\n        let with_auth = client.with_token(\"token\");\n        assert_eq!(with_auth.parameters.len(), 1);\n        assert_eq!(with_auth.parameters.get(\"db\").unwrap(), \"database\");\n        assert_eq!(with_auth.token.unwrap(), \"token\");\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[9268444,9268503],"length":1,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[9268530,9268590],"length":1,"stats":{"Line":2}},{"line":53,"address":[8931088],"length":1,"stats":{"Line":1}},{"line":54,"address":[9547618],"length":1,"stats":{"Line":1}},{"line":55,"address":[8931133],"length":1,"stats":{"Line":1}},{"line":56,"address":[8931176],"length":1,"stats":{"Line":1}},{"line":77,"address":[8758944,8758914,8758861,8759660,8758176,8759621],"length":1,"stats":{"Line":9}},{"line":82,"address":[9064304,9063589],"length":1,"stats":{"Line":9}},{"line":83,"address":[8942236,8942316],"length":1,"stats":{"Line":18}},{"line":85,"address":[8758503,8759263],"length":1,"stats":{"Line":9}},{"line":86,"address":[9064650,9064766,9063906,9064022],"length":1,"stats":{"Line":18}},{"line":87,"address":[9064030,9064774],"length":1,"stats":{"Line":9}},{"line":107,"address":[9077368,9077406,9076704],"length":1,"stats":{"Line":3}},{"line":112,"address":[9076786,9076892],"length":1,"stats":{"Line":8}},{"line":113,"address":[],"length":0,"stats":{"Line":8}},{"line":114,"address":[8945395],"length":1,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":5}},{"line":116,"address":[8945631],"length":1,"stats":{"Line":3}},{"line":121,"address":[9271888,9272017],"length":1,"stats":{"Line":0}},{"line":122,"address":[8941956,8942021],"length":1,"stats":{"Line":0}},{"line":123,"address":[9554013],"length":1,"stats":{"Line":0}},{"line":131,"address":[8941366,8941104],"length":1,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[9553392],"length":1,"stats":{"Line":1}},{"line":142,"address":[8941429],"length":1,"stats":{"Line":1}},{"line":146,"address":[8941392],"length":1,"stats":{"Line":1}},{"line":147,"address":[9271349],"length":1,"stats":{"Line":1}},{"line":153,"address":[9272056,9272048,9272064,9272665,9274012,9272111,9272266,9272215],"length":1,"stats":{"Line":4}},{"line":154,"address":[9554200,9554321],"length":1,"stats":{"Line":2}},{"line":155,"address":[8943660,8943350,8943701,8943599,8943185,8943768],"length":1,"stats":{"Line":5}},{"line":157,"address":[9554473],"length":1,"stats":{"Line":1}},{"line":159,"address":[9272642,9272889,9272575,9272245,9272699],"length":1,"stats":{"Line":4}},{"line":160,"address":[9556283,9556336,9556342,9554966,9556208],"length":1,"stats":{"Line":1}},{"line":161,"address":[9556226],"length":1,"stats":{"Line":0}},{"line":167,"address":[9273480],"length":1,"stats":{"Line":1}},{"line":168,"address":[9555300,9555233],"length":1,"stats":{"Line":2}},{"line":170,"address":[9274153,9273292,9274144],"length":1,"stats":{"Line":3}},{"line":171,"address":[9555390],"length":1,"stats":{"Line":1}},{"line":172,"address":[9274096,9274105,9273407],"length":1,"stats":{"Line":3}},{"line":176,"address":[9555660,9555570],"length":1,"stats":{"Line":2}},{"line":217,"address":[8759876,8765108,8759680,8759712],"length":1,"stats":{"Line":8}},{"line":221,"address":[9065583,9070643,9073485,9065338,9070891,9070797,9076042,9075968,9065489,9076634,9076560,9076090,9076682,9068118],"length":1,"stats":{"Line":10}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[8760340,8760424,8765632,8765548],"length":1,"stats":{"Line":10}},{"line":226,"address":[9071237,9065914,9065839,9071156],"length":1,"stats":{"Line":12}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[9066057,9071380],"length":1,"stats":{"Line":2}},{"line":229,"address":[8760827,8766020,8760736,8765929],"length":1,"stats":{"Line":6}},{"line":230,"address":[8760967,8761058,8766231,8766152],"length":1,"stats":{"Line":6}},{"line":232,"address":[],"length":0,"stats":{"Line":7}},{"line":233,"address":[9066637,9072177,9066843,9071965],"length":1,"stats":{"Line":2}},{"line":235,"address":[9066738,9072066],"length":1,"stats":{"Line":3}},{"line":238,"address":[9065959,9071282],"length":1,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":241,"address":[],"length":0,"stats":{"Line":6}},{"line":243,"address":[9067461,9067572,9067741,9072804,9068064,9072777,9072918,9067434,9073090,9073431],"length":1,"stats":{"Line":6}},{"line":247,"address":[8762634,8763680,8763105,8768165,8767799,8768826,8768111,8768251,8762959,8763016],"length":1,"stats":{"Line":21}},{"line":248,"address":[],"length":0,"stats":{"Line":4}},{"line":250,"address":[8770704,8770779,8770848,8762548,8770832,8770923,8770982,8770838,8767713,8770976],"length":1,"stats":{"Line":9}},{"line":251,"address":[9076130,9076434],"length":1,"stats":{"Line":1}},{"line":253,"address":[9073734,9068042,9073406,9067979,9073554,9073841,9068358,9065387,9070692,9068184,9068462,9073337],"length":1,"stats":{"Line":25}},{"line":254,"address":[],"length":0,"stats":{"Line":14}},{"line":256,"address":[8763482,8768628],"length":1,"stats":{"Line":6}},{"line":258,"address":[9075956,9065408,9075808,9076345,9070269,9075950,9069452,9075897,9076398,9074517,9074357,9068963,9070713,9076256,9076404,9069111,9074861,9075696],"length":1,"stats":{"Line":11}},{"line":259,"address":[8770562,8770114],"length":1,"stats":{"Line":0}},{"line":263,"address":[8769525,8764383,8764202,8764273,8769344,8769415],"length":1,"stats":{"Line":19}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[9069730,9070069,9075496,9075139],"length":1,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":6}},{"line":272,"address":[9553472,9553861,9553890],"length":1,"stats":{"Line":3}},{"line":273,"address":[9553641,9553507],"length":1,"stats":{"Line":6}},{"line":274,"address":[8941578,8941886,8941662],"length":1,"stats":{"Line":0}},{"line":276,"address":[9271615],"length":1,"stats":{"Line":4}},{"line":281,"address":[9553200],"length":1,"stats":{"Line":3}},{"line":282,"address":[9271214],"length":1,"stats":{"Line":3}},{"line":283,"address":[9271224],"length":1,"stats":{"Line":3}},{"line":284,"address":[9271238],"length":1,"stats":{"Line":1}},{"line":286,"address":[9271318],"length":1,"stats":{"Line":3}}],"covered":74,"coverable":85},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","error.rs"],"content":"//! Errors that might happen in the crate\n\nuse thiserror::Error;\n\n#[derive(Debug, Eq, PartialEq, Error)]\n#[non_exhaustive]\npub enum Error {\n    #[error(\"query is invalid: {error}\")]\n    /// Error happens when a query is invalid\n    InvalidQueryError { error: String },\n\n    #[error(\"Failed to build URL: {error}\")]\n    /// Error happens when a query is invalid\n    UrlConstructionError { error: String },\n\n    #[error(\"http protocol error: {error}\")]\n    /// Error happens when a query is invalid\n    ProtocolError { error: String },\n\n    #[error(\"http protocol error: {error}\")]\n    /// Error happens when Serde cannot deserialize the response\n    DeserializationError { error: String },\n\n    #[error(\"InfluxDB encountered the following error: {error}\")]\n    /// Error which has happened inside InfluxDB\n    DatabaseError { error: String },\n\n    #[error(\"API error with a status code: {0}\")]\n    /// Error happens when API returns non 2xx status code.\n    ApiError(u16),\n\n    #[error(\"connection error: {error}\")]\n    /// Error happens when HTTP request fails\n    ConnectionError { error: String },\n}\n\n#[cfg(feature = \"chrono\")]\n#[derive(Clone, Copy, Debug, Error)]\n#[error(\"The timestamp is too large to fit into an i64.\")]\npub struct TimestampTooLargeError(pub(crate) ());\n\n#[cfg(any(feature = \"chrono\", feature = \"time\"))]\n#[derive(Clone, Copy, Debug, Error)]\npub enum TimeTryFromError<T, I> {\n    TimeError(#[source] T),\n    IntError(#[source] I),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","integrations","serde_integration","de.rs"],"content":"use super::{Series, TaggedSeries};\nuse serde::de::{\n    value, Deserialize, DeserializeSeed, Deserializer, Error, IntoDeserializer, MapAccess,\n    SeqAccess, Visitor,\n};\nuse serde_derive::Deserialize;\nuse std::fmt;\nuse std::marker::PhantomData;\n\n// Based on https://serde.rs/deserialize-struct.html\nimpl<'de, T> Deserialize<'de> for Series<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // Field name deserializer\n        #[derive(Deserialize)]\n        #[serde(field_identifier, rename_all = \"lowercase\")]\n        enum Field {\n            Name,\n            Columns,\n            Values,\n        }\n\n        struct SeriesVisitor<T> {\n            _inner_type: PhantomData<T>,\n        }\n\n        impl<'de, T> Visitor<'de> for SeriesVisitor<T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = Series<T>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"struct Series\")\n            }\n\n            fn visit_map<V>(self, mut map: V) -> Result<Series<T>, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                let mut name = None;\n                let mut columns: Option<Vec<String>> = None;\n                let mut values: Option<Vec<T>> = None;\n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Field::Name => {\n                            if name.is_some() {\n                                return Err(Error::duplicate_field(\"name\"));\n                            }\n                            name = Some(map.next_value()?);\n                        }\n                        Field::Columns => {\n                            if columns.is_some() {\n                                return Err(Error::duplicate_field(\"columns\"));\n                            }\n                            columns = Some(map.next_value()?);\n                        }\n                        Field::Values => {\n                            if values.is_some() {\n                                return Err(Error::duplicate_field(\"values\"));\n                            }\n                            // Error out if \"values\" is encountered before \"columns\"\n                            // Hopefully, InfluxDB never does this.\n                            if columns.is_none() {\n                                return Err(Error::custom(\n                                    \"series values encountered before columns\",\n                                ));\n                            }\n                            // Deserialize using a HeaderVec deserializer\n                            // seeded with the headers from the \"columns\" field\n                            values = Some(map.next_value_seed(HeaderVec::<T> {\n                                header: columns.as_ref().unwrap(),\n                                _inner_type: PhantomData,\n                            })?);\n                        }\n                    }\n                }\n                let name = name.ok_or_else(|| Error::missing_field(\"name\"))?;\n                let values = values.unwrap_or_default();\n\n                Ok(Series { name, values })\n            }\n        }\n\n        const FIELDS: &[&str] = &[\"name\", \"values\"];\n        deserializer.deserialize_struct(\n            \"Series\",\n            FIELDS,\n            SeriesVisitor::<T> {\n                _inner_type: PhantomData,\n            },\n        )\n    }\n}\n\n// Based on https://serde.rs/deserialize-struct.html\nimpl<'de, TAG, T> Deserialize<'de> for TaggedSeries<TAG, T>\nwhere\n    TAG: Deserialize<'de>,\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // Field name deserializer\n        #[derive(Deserialize)]\n        #[serde(field_identifier, rename_all = \"lowercase\")]\n        enum Field {\n            Name,\n            Tags,\n            Columns,\n            Values,\n        }\n\n        struct SeriesVisitor<TAG, T> {\n            _tag_type: PhantomData<TAG>,\n            _value_type: PhantomData<T>,\n        }\n\n        impl<'de, TAG, T> Visitor<'de> for SeriesVisitor<TAG, T>\n        where\n            TAG: Deserialize<'de>,\n            T: Deserialize<'de>,\n        {\n            type Value = TaggedSeries<TAG, T>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"struct TaggedSeries\")\n            }\n\n            fn visit_map<V>(self, mut map: V) -> Result<TaggedSeries<TAG, T>, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                let mut name = None;\n                let mut tags: Option<TAG> = None;\n                let mut columns: Option<Vec<String>> = None;\n                let mut values: Option<Vec<T>> = None;\n                while let Some(key) = map.next_key()? {\n                    match key {\n                        Field::Name => {\n                            if name.is_some() {\n                                return Err(Error::duplicate_field(\"name\"));\n                            }\n                            name = Some(map.next_value()?);\n                        }\n                        Field::Tags => {\n                            if tags.is_some() {\n                                return Err(Error::duplicate_field(\"tags\"));\n                            }\n                            tags = Some(map.next_value()?);\n                        }\n                        Field::Columns => {\n                            if columns.is_some() {\n                                return Err(Error::duplicate_field(\"columns\"));\n                            }\n                            columns = Some(map.next_value()?);\n                        }\n                        Field::Values => {\n                            if values.is_some() {\n                                return Err(Error::duplicate_field(\"values\"));\n                            }\n                            // Error out if \"values\" is encountered before \"columns\"\n                            // Hopefully, InfluxDB never does this.\n                            if columns.is_none() {\n                                return Err(Error::custom(\n                                    \"series values encountered before columns\",\n                                ));\n                            }\n                            // Deserialize using a HeaderVec deserializer\n                            // seeded with the headers from the \"columns\" field\n                            values = Some(map.next_value_seed(HeaderVec::<T> {\n                                header: columns.as_ref().unwrap(),\n                                _inner_type: PhantomData,\n                            })?);\n                        }\n                    }\n                }\n                let name = name.ok_or_else(|| Error::missing_field(\"name\"))?;\n                let tags = tags.ok_or_else(|| Error::missing_field(\"tags\"))?;\n                let values = values.ok_or_else(|| Error::missing_field(\"values\"))?;\n                Ok(TaggedSeries { name, tags, values })\n            }\n        }\n\n        const FIELDS: &[&str] = &[\"name\", \"tags\", \"values\"];\n        deserializer.deserialize_struct(\n            \"TaggedSeries\",\n            FIELDS,\n            SeriesVisitor::<TAG, T> {\n                _tag_type: PhantomData,\n                _value_type: PhantomData,\n            },\n        )\n    }\n}\n\n// Deserializer that takes a header as a seed\n// and deserializes an array of arrays into a\n// Vec of map-like values using the header as\n// keys and the values as values.\nstruct HeaderVec<'h, T> {\n    header: &'h [String],\n    _inner_type: PhantomData<T>,\n}\n\nimpl<'de, 'h, T> DeserializeSeed<'de> for HeaderVec<'h, T>\nwhere\n    T: Deserialize<'de>,\n{\n    type Value = Vec<T>;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct HeaderVecVisitor<'h, T> {\n            header: &'h [String],\n            _inner_type: PhantomData<T>,\n        }\n        impl<'de, 'h, T> Visitor<'de> for HeaderVecVisitor<'h, T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = Vec<T>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                write!(formatter, \"an array of arrays\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Vec<T>, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let mut vec = Vec::new();\n\n                while let Some(v) = seq.next_element_seed(RowWithHeader {\n                    header: self.header,\n                    _inner_type: PhantomData,\n                })? {\n                    vec.push(v);\n                }\n\n                Ok(vec)\n            }\n        }\n        deserializer.deserialize_seq(HeaderVecVisitor {\n            header: self.header,\n            _inner_type: PhantomData,\n        })\n    }\n}\n\n// Deserializer that takes a header as a seed\n// and deserializes an array into a map-like\n// value using the header as keys and the values\n// as values.\nstruct RowWithHeader<'h, T> {\n    header: &'h [String],\n    _inner_type: PhantomData<T>,\n}\n\nimpl<'de, 'h, T> DeserializeSeed<'de> for RowWithHeader<'h, T>\nwhere\n    T: Deserialize<'de>,\n{\n    type Value = T;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct RowWithHeaderVisitor<'h, T> {\n            header: &'h [String],\n            _inner: PhantomData<fn() -> T>,\n        }\n\n        impl<'de, 'h, T> Visitor<'de> for RowWithHeaderVisitor<'h, T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = T;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"array\")\n            }\n\n            fn visit_seq<A>(self, seq: A) -> Result<T, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                // `MapAccessDeserializer` is a wrapper that turns a `MapAccess`\n                // into a `Deserializer`, allowing it to be used as the input to T's\n                // `Deserialize` implementation. T then deserializes itself using\n                // the entries from the map visitor.\n                Deserialize::deserialize(value::MapAccessDeserializer::new(HeaderMapAccess {\n                    header: self.header,\n                    field: 0,\n                    data: seq,\n                }))\n            }\n        }\n\n        deserializer.deserialize_seq(RowWithHeaderVisitor {\n            header: self.header,\n            _inner: PhantomData,\n        })\n    }\n}\n\n// MapAccess implementation that holds a reference to\n// the header for keys and a serde sequence for values.\n// When asked for a key, it returns the next header and\n// advances its header field index. When asked for a value,\n// it tries to deserialize the next element in the serde\n// sequence into the desired type, and returns an error\n// if no element is returned (the sequence is exhausted).\nstruct HeaderMapAccess<'h, A> {\n    header: &'h [String],\n    field: usize,\n    data: A,\n}\n\nimpl<'de, 'h, A> MapAccess<'de> for HeaderMapAccess<'h, A>\nwhere\n    A: SeqAccess<'de>,\n{\n    type Error = <A as SeqAccess<'de>>::Error;\n\n    fn next_key_seed<K: DeserializeSeed<'de>>(\n        &mut self,\n        seed: K,\n    ) -> Result<Option<K::Value>, Self::Error> {\n        let field = match self.header.get(self.field) {\n            None => return Ok(None),\n            Some(field) => field,\n        };\n        self.field += 1;\n        seed.deserialize(field.clone().into_deserializer())\n            .map(Some)\n    }\n\n    fn next_value_seed<K: DeserializeSeed<'de>>(\n        &mut self,\n        seed: K,\n    ) -> Result<K::Value, Self::Error> {\n        match self.data.next_element_seed(seed)? {\n            Some(value) => Ok(value),\n            None => Err(Error::custom(\"next_value_seed called but no value\")),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Series;\n    use std::borrow::Cow;\n    use std::collections::HashMap;\n\n    const TEST_DATA: &str = r#\"\n    {\n        \"name\": \"series_name\",\n        \"columns\": [\"foo\", \"bar\"],\n        \"values\": [\n            [\"foo_a\", \"bar_a\"],\n            [\"foo_b\", \"bar_b\"]\n        ]\n    }\n    \"#;\n\n    // we can derive all the impls we want here\n    #[derive(Debug, PartialEq, Eq)]\n    struct EqSeries<T> {\n        pub name: String,\n        pub values: Vec<T>,\n    }\n\n    impl<T> From<Series<T>> for EqSeries<T> {\n        fn from(Series { name, values }: Series<T>) -> Self {\n            EqSeries { name, values }\n        }\n    }\n\n    #[test]\n    fn test_deserialize_cow() {\n        // Unfortunately, Cow is not automatically borrowed,\n        // so this is basically equivalent to String, String\n        let result = serde_json::from_str::<Series<HashMap<Cow<'_, str>, Cow<'_, str>>>>(TEST_DATA);\n        assert!(result.is_ok());\n        assert_eq!(\n            EqSeries::from(result.unwrap()),\n            EqSeries {\n                name: \"series_name\".into(),\n                values: vec![\n                    {\n                        let mut h = std::collections::HashMap::new();\n                        h.insert(\"foo\".into(), \"foo_a\".into());\n                        h.insert(\"bar\".into(), \"bar_a\".into());\n                        h\n                    },\n                    {\n                        let mut h = std::collections::HashMap::new();\n                        h.insert(\"foo\".into(), \"foo_b\".into());\n                        h.insert(\"bar\".into(), \"bar_b\".into());\n                        h\n                    },\n                ],\n            },\n        );\n    }\n\n    #[test]\n    fn test_deserialize_borrowed() {\n        use serde_derive::Deserialize;\n\n        // Deserializing a string that cannot be passed through\n        // without escaping will result in an error like this:\n        // `invalid type: string \"\\n\", expected a borrowed string at line 6 column 43`\n        // but if it doesn't need escaping it's fine.\n        #[derive(Deserialize, Debug, PartialEq, Eq)]\n        struct BorrowingStruct<'a> {\n            foo: &'a str,\n            bar: &'a str,\n        }\n\n        let result = serde_json::from_str::<Series<BorrowingStruct<'_>>>(TEST_DATA);\n        assert!(result.is_ok(), \"{}\", result.unwrap_err());\n        assert_eq!(\n            EqSeries::from(result.unwrap()),\n            EqSeries {\n                name: \"series_name\".into(),\n                values: vec![\n                    BorrowingStruct {\n                        foo: \"foo_a\",\n                        bar: \"bar_a\",\n                    },\n                    BorrowingStruct {\n                        foo: \"foo_b\",\n                        bar: \"bar_b\",\n                    },\n                ],\n            },\n        );\n    }\n}\n","traces":[{"line":15,"address":[9113744,9114032,9113936,9113840,9114128],"length":1,"stats":{"Line":8}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[8751152,8751216],"length":1,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[8894897,8892416,8887105,8892337,8897345,8897457,8887296,8884736,8889856,8889665,8887217,8889777,8892225,8894976,8894785],"length":1,"stats":{"Line":8}},{"line":46,"address":[8723174],"length":1,"stats":{"Line":8}},{"line":47,"address":[],"length":0,"stats":{"Line":8}},{"line":48,"address":[8723231],"length":1,"stats":{"Line":8}},{"line":49,"address":[8723270,8723334,8725532],"length":1,"stats":{"Line":16}},{"line":50,"address":[8723467],"length":1,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[8723551,8723619],"length":1,"stats":{"Line":16}},{"line":53,"address":[8723645,8724020],"length":1,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":16}},{"line":57,"address":[8755148,8752556],"length":1,"stats":{"Line":8}},{"line":58,"address":[],"length":0,"stats":{"Line":16}},{"line":59,"address":[8724420,8724069],"length":1,"stats":{"Line":0}},{"line":61,"address":[8724405,8724062,8724116,8724277],"length":1,"stats":{"Line":16}},{"line":63,"address":[],"length":0,"stats":{"Line":8}},{"line":64,"address":[8723601,8724446],"length":1,"stats":{"Line":16}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":16}},{"line":70,"address":[8891236,8891677,8893796,8889117,8894237,8888676,8886116,8896356,8896797,8886557],"length":1,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":8}},{"line":77,"address":[],"length":0,"stats":{"Line":16}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[8887111,8887630,8897633,8892750,8897600,8889671,8886611,8891731,8897665,8896851,8894291,8889171,8892231,8885070,8894791,8890190,8897351,8897536,8897537,8897569,8897568,8897601,8897632,8895310,8897664],"length":1,"stats":{"Line":16}},{"line":84,"address":[8755939,8753347],"length":1,"stats":{"Line":8}},{"line":86,"address":[8897129,8889449,8886889,8892009,8894569],"length":1,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[9114224],"length":1,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[8897696],"length":1,"stats":{"Line":0}},{"line":134,"address":[8897721],"length":1,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[8897782],"length":1,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[8897873],"length":1,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[8898304,8898686],"length":1,"stats":{"Line":0}},{"line":151,"address":[8898517,8898297,8898335,8898655],"length":1,"stats":{"Line":2}},{"line":153,"address":[8899082],"length":1,"stats":{"Line":1}},{"line":154,"address":[8898216,8898709],"length":1,"stats":{"Line":2}},{"line":155,"address":[8898735,8899102],"length":1,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[8899147,8899201,8899362,8899490],"length":1,"stats":{"Line":2}},{"line":165,"address":[8900038],"length":1,"stats":{"Line":1}},{"line":166,"address":[8898260,8899531],"length":1,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[8899715,8899803,8899899,8900043],"length":1,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[8901504,8901505,8900278,8900401,8901140],"length":1,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[8900785],"length":1,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[8720656],"length":1,"stats":{"Line":9}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[8722336],"length":1,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":9}},{"line":241,"address":[],"length":0,"stats":{"Line":18}},{"line":243,"address":[8749879,8749915,8749825,8750417,8750366,8750453],"length":1,"stats":{"Line":18}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":18}},{"line":250,"address":[8882804,8880628,8883333,8881716,8882260,8881172],"length":1,"stats":{"Line":9}},{"line":253,"address":[],"length":0,"stats":{"Line":9}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[8747424,8747488],"length":1,"stats":{"Line":9}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[8883776,8883456,8883584,8883520,8883648,8883712],"length":1,"stats":{"Line":0}},{"line":291,"address":[8750857,8750793],"length":1,"stats":{"Line":0}},{"line":294,"address":[8884224,8883840,8883936,8884032,8884128,8884320],"length":1,"stats":{"Line":9}},{"line":302,"address":[],"length":0,"stats":{"Line":9}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[8879662,8879470,8879374,8879758,8879278,8879566],"length":1,"stats":{"Line":9}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[8719440,8719826],"length":1,"stats":{"Line":9}},{"line":340,"address":[],"length":0,"stats":{"Line":18}},{"line":341,"address":[8877573,8875493,8877157,8875909,8876741,8876325],"length":1,"stats":{"Line":9}},{"line":342,"address":[],"length":0,"stats":{"Line":9}},{"line":344,"address":[8877129,8877607,8875527,8875557,8877545,8877637,8877221,8875973,8876297,8875943,8876359,8875881,8875465,8876389,8876805,8877191,8876713,8876775],"length":1,"stats":{"Line":18}},{"line":345,"address":[8719675,8719721,8719816],"length":1,"stats":{"Line":18}},{"line":346,"address":[8877329,8875665,8877745,8876081,8876497,8876913],"length":1,"stats":{"Line":9}},{"line":349,"address":[8878016,8878320,8877792,8878480],"length":1,"stats":{"Line":8}},{"line":353,"address":[8878037,8877810,8878499,8878332],"length":1,"stats":{"Line":8}},{"line":354,"address":[],"length":0,"stats":{"Line":8}},{"line":355,"address":[],"length":0,"stats":{"Line":0}}],"covered":70,"coverable":112},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","integrations","serde_integration","mod.rs"],"content":"//! Serde Integration for InfluxDB. Provides deserialization of query returns.\n//!\n//! When querying multiple series in the same query (e.g. with a regex query), it might be desirable to flat map\n//! the resulting series into a single `Vec` like so. The example assumes, that there are weather readings in multiple\n//! series named `weather_<city_name>` (e.g. `weather_berlin`, or `weather_london`). Since we're using a Regex query,\n//! we don't actually know which series will be returned. To assign the city name to the series, we can use the series\n//! `name`, InfluxDB provides alongside query results.\n//!\n//! ```rust,no_run\n//! use influxdb::{Client, Query as _, ReadQuery};\n//! use serde_derive::Deserialize;\n//!\n//! #[derive(Deserialize)]\n//! struct WeatherWithoutCityName {\n//!     temperature: i32,\n//! }\n//!\n//! #[derive(Deserialize)]\n//! struct Weather {\n//!     city_name: String,\n//!     weather: WeatherWithoutCityName,\n//! }\n//!\n//! # #[tokio::main]\n//! # async fn main() -> Result<(), influxdb::Error> {\n//! let client = Client::new(\"http://localhost:8086\", \"test\");\n//! let query = ReadQuery::new(\n//!     \"SELECT temperature FROM /weather_[a-z]*$/ WHERE time > now() - 1m ORDER BY DESC\",\n//! );\n//! let mut db_result = client.json_query(query).await?;\n//! let _result = db_result\n//!     .deserialize_next::<WeatherWithoutCityName>()?\n//!     .series\n//!     .into_iter()\n//!     .map(|mut city_series| {\n//!         let city_name = city_series.name.split(\"_\").collect::<Vec<&str>>().remove(2);\n//!         Weather {\n//!             weather: city_series.values.remove(0),\n//!             city_name: city_name.to_string(),\n//!         }\n//!     })\n//!     .collect::<Vec<Weather>>();\n//! # Ok(())\n//! # }\n//! ```\n\nmod de;\n\nuse serde::de::DeserializeOwned;\nuse serde_derive::Deserialize;\n\nuse crate::client::check_status;\nuse crate::{Client, Error, Query, ReadQuery};\n\n#[derive(Deserialize)]\n#[doc(hidden)]\nstruct _DatabaseError {\n    error: String,\n}\n\n#[derive(Deserialize, Debug)]\n#[doc(hidden)]\npub struct DatabaseQueryResult {\n    pub results: Vec<serde_json::Value>,\n}\n\nimpl DatabaseQueryResult {\n    pub fn deserialize_next<T: 'static>(&mut self) -> Result<Return<T>, Error>\n    where\n        T: DeserializeOwned + Send,\n    {\n        serde_json::from_value::<Return<T>>(self.results.remove(0)).map_err(|err| {\n            Error::DeserializationError {\n                error: format!(\"could not deserialize: {err}\"),\n            }\n        })\n    }\n\n    pub fn deserialize_next_tagged<TAG, T: 'static>(\n        &mut self,\n    ) -> Result<TaggedReturn<TAG, T>, Error>\n    where\n        TAG: DeserializeOwned + Send,\n        T: DeserializeOwned + Send,\n    {\n        serde_json::from_value::<TaggedReturn<TAG, T>>(self.results.remove(0)).map_err(|err| {\n            Error::DeserializationError {\n                error: format!(\"could not deserialize: {err}\"),\n            }\n        })\n    }\n}\n\n#[derive(Deserialize, Debug)]\n#[doc(hidden)]\npub struct Return<T> {\n    #[serde(default = \"Vec::new\")]\n    pub series: Vec<Series<T>>,\n}\n\n#[derive(Debug)]\n/// Represents a returned series from InfluxDB\npub struct Series<T> {\n    pub name: String,\n    pub values: Vec<T>,\n}\n\n#[derive(Deserialize, Debug)]\n#[doc(hidden)]\npub struct TaggedReturn<TAG, T> {\n    #[serde(default = \"Vec::new\")]\n    pub series: Vec<TaggedSeries<TAG, T>>,\n}\n\n#[derive(Debug)]\n/// Represents a returned series from InfluxDB\npub struct TaggedSeries<TAG, T> {\n    pub name: String,\n    pub tags: TAG,\n    pub values: Vec<T>,\n}\n\nimpl Client {\n    pub async fn json_query(&self, q: ReadQuery) -> Result<DatabaseQueryResult, Error> {\n        let query = q.build().map_err(|err| Error::InvalidQueryError {\n            error: err.to_string(),\n        })?;\n\n        let read_query = query.get();\n        let read_query_lower = read_query.to_lowercase();\n\n        if !read_query_lower.contains(\"select\") && !read_query_lower.contains(\"show\") {\n            let error = Error::InvalidQueryError {\n                error: \"Only SELECT and SHOW queries supported with JSON deserialization\".into(),\n            };\n            return Err(error);\n        }\n\n        let url = &format!(\"{}/query\", &self.url);\n        let mut parameters = self.parameters.as_ref().clone();\n        parameters.insert(\"q\", read_query);\n        let mut request_builder = self.client.get(url);\n        if let Some(ref token) = self.token {\n            request_builder = request_builder.header(\"Authorization\", format!(\"Token {token}\"))\n        }\n        let request_builder = request_builder.query(&parameters);\n\n        let res = request_builder\n            .send()\n            .await\n            .map_err(|err| Error::ConnectionError {\n                error: err.to_string(),\n            })?;\n        check_status(&res)?;\n\n        let body = res.bytes();\n\n        let body = body.await.map_err(|err| Error::ProtocolError {\n            error: err.to_string(),\n        })?;\n\n        // Try parsing InfluxDBs { \"error\": \"error message here\" }\n        if let Ok(error) = serde_json::from_slice::<_DatabaseError>(&body) {\n            return Err(Error::DatabaseError { error: error.error });\n        }\n\n        // Json has another structure, let's try actually parsing it to the type we're deserializing\n        serde_json::from_slice::<DatabaseQueryResult>(&body).map_err(|err| {\n            Error::DeserializationError {\n                error: format!(\"serde error: {err}\"),\n            }\n        })\n    }\n}\n","traces":[{"line":68,"address":[9111136,9111056,9111216,9111296,9111376],"length":1,"stats":{"Line":6}},{"line":72,"address":[8804352,8804591,8804597,8804291],"length":1,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[9112816],"length":1,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[9112923,9112988],"length":1,"stats":{"Line":0}},{"line":124,"address":[9553096,9553088],"length":1,"stats":{"Line":10}},{"line":125,"address":[9302778,9297134,9302656,9299406,9297373,9297259,9302730],"length":1,"stats":{"Line":4}},{"line":126,"address":[9302674],"length":1,"stats":{"Line":0}},{"line":129,"address":[9579662,9579537],"length":1,"stats":{"Line":4}},{"line":130,"address":[9297653,9297749],"length":1,"stats":{"Line":4}},{"line":132,"address":[9579879,9580031,9579788],"length":1,"stats":{"Line":5}},{"line":134,"address":[9298058],"length":1,"stats":{"Line":1}},{"line":136,"address":[9580170],"length":1,"stats":{"Line":1}},{"line":139,"address":[8848484,8848197],"length":1,"stats":{"Line":4}},{"line":140,"address":[9298400,9298487],"length":1,"stats":{"Line":4}},{"line":141,"address":[8848742,8848859],"length":1,"stats":{"Line":4}},{"line":142,"address":[9298670],"length":1,"stats":{"Line":2}},{"line":143,"address":[9298701,9299148],"length":1,"stats":{"Line":2}},{"line":144,"address":[8849378,8849118,8848969,8849365],"length":1,"stats":{"Line":0}},{"line":146,"address":[8849078],"length":1,"stats":{"Line":2}},{"line":148,"address":[9299737,9299650,9300431,9299711,9299227,9299361,9299824],"length":1,"stats":{"Line":10}},{"line":150,"address":[9297183,9299475,9299322,9299660,9299383],"length":1,"stats":{"Line":8}},{"line":151,"address":[8852896,8852967,8853026,8853020,8849926],"length":1,"stats":{"Line":2}},{"line":152,"address":[9302258],"length":1,"stats":{"Line":0}},{"line":154,"address":[9582003,9582422,9582070],"length":1,"stats":{"Line":5}},{"line":156,"address":[9582234],"length":1,"stats":{"Line":2}},{"line":158,"address":[9302033,9300797,9297204,9300474,9302875,9302928,9302800,9302934,9300316],"length":1,"stats":{"Line":4}},{"line":159,"address":[9302818],"length":1,"stats":{"Line":0}},{"line":163,"address":[9300938,9301009,9301111],"length":1,"stats":{"Line":4}},{"line":164,"address":[9301159],"length":1,"stats":{"Line":0}},{"line":168,"address":[9301434,9302623,9301502,9302629,9302384],"length":1,"stats":{"Line":4}},{"line":169,"address":[9302567],"length":1,"stats":{"Line":0}},{"line":170,"address":[9302411,9302476],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":36},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","lib.rs"],"content":"//! Pull requests are always welcome. See [Contributing](https://github.com/influxdb-rs/influxdb-rust/blob/main/CONTRIBUTING.md) and [Code of Conduct](https://github.com/influxdb-rs/influxdb-rust/blob/main/CODE_OF_CONDUCT.md). For a list of past changes, see [CHANGELOG.md](https://github.com/influxdb-rs/influxdb-rust/blob/main/CHANGELOG.md).\n//!\n//! ## Currently Supported Features\n//!\n//! -   Reading and writing to InfluxDB\n//! -   Optional Serde support for deserialization\n//! -   Running multiple queries in one request (e.g. `SELECT * FROM weather_berlin; SELECT * FROM weather_london`)\n//! -   Writing single or multiple measurements in one request (e.g. `WriteQuery` or `Vec<WriteQuery>` argument)\n//! -   Authenticated and unauthenticated connections\n//! -   `async`/`await` support\n//! -   `#[derive(InfluxDbWriteable)]` derive macro for writing / reading into structs\n//! -   `GROUP BY` support\n//! -   Tokio and async-std support (see example below) or [available backends](https://github.com/influxdb-rs/influxdb-rust/blob/main/influxdb/Cargo.toml)\n//! -   Swappable HTTP backends ([see below](#Choice-of-HTTP-backend))\n//!\n//! # Quickstart\n//!\n//! Add the following to your `Cargo.toml`\n#![doc = cargo_toml!(indent=\"\", \"derive\")]\n//!\n//! For an example with using Serde deserialization, please refer to [serde_integration](crate::integrations::serde_integration)\n//!\n//! ```rust,no_run\n//! use chrono::{DateTime, Utc};\n//! use influxdb::{Client, Error, InfluxDbWriteable, ReadQuery, Timestamp};\n//!\n//! #[tokio::main]\n//! async fn main() -> Result<(), Error> {\n//!     // Connect to db `test` on `http://localhost:8086`\n//!     let client = Client::new(\"http://localhost:8086\", \"test\");\n//!\n//!     #[derive(InfluxDbWriteable)]\n//!     struct WeatherReading {\n//!         time: DateTime<Utc>,\n//!         humidity: i32,\n//!         #[influxdb(tag)]\n//!         wind_direction: String,\n//!     }\n//!\n//!     // Let's write some data into a measurement called `weather`\n//!     let weather_readings = vec![\n//!         WeatherReading {\n//!             time: Timestamp::Hours(1).try_into().unwrap(),\n//!             humidity: 30,\n//!             wind_direction: String::from(\"north\"),\n//!         }\n//!         .try_into_query(\"weather\")\n//!         .unwrap(),\n//!         WeatherReading {\n//!             time: Timestamp::Hours(2).try_into().unwrap(),\n//!             humidity: 40,\n//!             wind_direction: String::from(\"west\"),\n//!         }\n//!         .try_into_query(\"weather\")\n//!         .unwrap(),\n//!     ];\n//!\n//!     client.query(weather_readings).await?;\n//!\n//!     // Read back all records\n//!     let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n//!\n//!     let read_result = client.query(read_query).await?;\n//!     println!(\"{}\", read_result);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! For further examples, check out the integration tests in `tests/integration_tests.rs`\n//! in the repository.\n//!\n//! # Choice of HTTP backend\n//!\n//! To communicate with InfluxDB, you can choose the HTTP backend to be used configuring the appropriate feature. We recommend sticking with the default reqwest-based client, unless you really need async-std compatibility.\n//!\n//! - **[hyper](https://github.com/hyperium/hyper)** (through reqwest, used by default), with [rustls](https://github.com/ctz/rustls)\n#![doc = cargo_toml!(indent=\"\\t\", \"derive\")]\n//! - **[hyper](https://github.com/hyperium/hyper)** (through reqwest), with native TLS (OpenSSL)\n#![doc = cargo_toml!(indent=\"\\t\", default-features = false, \"derive\", \"serde\", \"native-tls\")]\n//! - **[hyper](https://github.com/hyperium/hyper)** (through reqwest), with vendored native TLS (OpenSSL)\n#![doc = cargo_toml!(indent=\"\\t\", default-features = false, \"derive\", \"serde\", \"native-tls-vendored\")]\n//!\n//! # License\n//!\n//! [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nmacro_rules! cargo_toml {\n    (indent=$indent:literal, $firstfeat:literal $(, $feature:literal)*) => {\n        cargo_toml_private!($indent, \"\", $firstfeat $(, $feature)*)\n    };\n\n    (indent=$indent:literal, default-features = false, $firstfeat:literal $(, $feature:literal)*) => {\n        cargo_toml_private!($indent, \"default-features = false, \", $firstfeat $(, $feature)*)\n    };\n}\nuse cargo_toml;\n\nmacro_rules! cargo_toml_private {\n    ($indent:literal, $deffeats:literal, $firstfeat:literal $(, $feature:literal)*) => {\n        concat!(\n            $indent,\n            \"```toml\\n\",\n\n            $indent,\n            \"influxdb = { version = \\\"\",\n            env!(\"CARGO_PKG_VERSION\"),\n            \"\\\", \",\n            $deffeats,\n            \"features = [\",\n            \"\\\"\", $firstfeat, \"\\\"\",\n            $(\", \\\"\", $feature, \"\\\"\",)*\n            \"] }\\n\",\n\n            $indent,\n            \"```\"\n        )\n    };\n}\nuse cargo_toml_private;\n\nmod client;\nmod error;\nmod query;\n\npub use client::Client;\npub use error::Error;\npub use query::read_query::ReadQuery;\npub use query::write_query::{Type, WriteQuery};\npub use query::{InfluxDbWriteable, Query, QueryType, Timestamp, ValidQuery};\n\n#[cfg(feature = \"serde\")]\npub mod integrations {\n    #[cfg(feature = \"serde\")]\n    pub mod serde_integration;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","query","consts.rs"],"content":"pub const MINUTES_PER_HOUR: u128 = 60;\npub const SECONDS_PER_MINUTE: u128 = 60;\npub const MILLIS_PER_SECOND: u128 = 1000;\npub const NANOS_PER_MILLI: u128 = 1_000_000;\npub const NANOS_PER_MICRO: u128 = 1000;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","query","line_proto_term.rs"],"content":"/// InfluxDB Line Protocol escaping helper module.\n/// https://docs.influxdata.com/influxdb/v1.7/write_protocols/line_protocol_tutorial/\nuse crate::Type;\nuse lazy_regex::{lazy_regex, Lazy, Regex};\n\npub static COMMAS_SPACES: Lazy<Regex> = lazy_regex!(\"[, ]\");\npub static COMMAS_SPACES_EQUALS: Lazy<Regex> = lazy_regex!(\"[, =]\");\npub static QUOTES_SLASHES: Lazy<Regex> = lazy_regex!(r#\"[\"\\\\]\"#);\npub static SLASHES: Lazy<Regex> = lazy_regex!(r#\"(\\\\|,| |=|\")\"#);\n\npub enum LineProtoTerm<'a> {\n    Measurement(&'a str), // escape commas, spaces\n    TagKey(&'a str),      // escape commas, equals, spaces\n    TagValue(&'a Type),   // escape commas, equals, spaces\n    FieldKey(&'a str),    // escape commas, equals, spaces\n    FieldValue(&'a Type), // escape quotes, backslashes + quote\n}\n\nimpl LineProtoTerm<'_> {\n    pub fn escape(self) -> String {\n        use LineProtoTerm::*;\n        match self {\n            Measurement(x) => Self::escape_any(x, &COMMAS_SPACES),\n            TagKey(x) | FieldKey(x) => Self::escape_any(x, &COMMAS_SPACES_EQUALS),\n            FieldValue(x) => Self::escape_field_value(x, false),\n            TagValue(x) => Self::escape_tag_value(x),\n        }\n    }\n\n    pub fn escape_v2(self) -> String {\n        use LineProtoTerm::*;\n        match self {\n            Measurement(x) => Self::escape_any(x, &COMMAS_SPACES),\n            TagKey(x) | FieldKey(x) => Self::escape_any(x, &COMMAS_SPACES_EQUALS),\n            FieldValue(x) => Self::escape_field_value(x, true),\n            TagValue(x) => Self::escape_tag_value(x),\n        }\n    }\n\n    fn escape_field_value(v: &Type, use_v2: bool) -> String {\n        use Type::*;\n        match v {\n            Boolean(v) => {\n                if *v {\n                    \"true\"\n                } else {\n                    \"false\"\n                }\n            }\n            .to_string(),\n            Float(v) => v.to_string(),\n            SignedInteger(v) => format!(\"{v}i\"),\n            UnsignedInteger(v) => {\n                if use_v2 {\n                    format!(\"{v}u\")\n                } else {\n                    format!(\"{v}i\")\n                }\n            }\n            Text(v) => format!(r#\"\"{}\"\"#, Self::escape_any(v, &QUOTES_SLASHES)),\n        }\n    }\n\n    fn escape_tag_value(v: &Type) -> String {\n        use Type::*;\n        match v {\n            Boolean(v) => {\n                if *v {\n                    \"true\"\n                } else {\n                    \"false\"\n                }\n            }\n            .into(),\n            Float(v) => v.to_string(),\n            SignedInteger(v) => v.to_string(),\n            UnsignedInteger(v) => v.to_string(),\n            Text(v) => Self::escape_any(v, &SLASHES),\n        }\n    }\n\n    fn escape_any(s: &str, re: &Regex) -> String {\n        re.replace_all(s, r\"\\$0\").to_string()\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use crate::query::line_proto_term::LineProtoTerm::*;\n    use crate::Type;\n\n    #[test]\n    fn test() {\n        assert_eq!(TagValue(&Type::Boolean(true)).escape(), r#\"true\"#);\n        assert_eq!(TagValue(&Type::Float(1.8324f64)).escape(), r#\"1.8324\"#);\n        assert_eq!(TagValue(&Type::SignedInteger(-1i64)).escape(), r#\"-1\"#);\n        assert_eq!(TagValue(&Type::UnsignedInteger(1u64)).escape(), r#\"1\"#);\n\n        assert_eq!(\n            TagValue(&Type::Text(\"this is my special string\".into())).escape(),\n            r\"this\\ is\\ my\\ special\\ string\"\n        );\n        assert_eq!(\n            TagValue(&Type::Text(\"a tag w=i th == tons of escapes\".into())).escape(),\n            r\"a\\ tag\\ w\\=i\\ th\\ \\=\\=\\ tons\\ of\\ escapes\"\n        );\n        assert_eq!(\n            TagValue(&Type::Text(\"no_escapes\".into())).escape(),\n            r#\"no_escapes\"#\n        );\n        assert_eq!(\n            TagValue(&Type::Text(\"some,commas,here\".into())).escape(),\n            r\"some\\,commas\\,here\"\n        );\n\n        assert_eq!(Measurement(r#\"wea\", ther\"#).escape(), r#\"wea\"\\,\\ ther\"#);\n        assert_eq!(TagKey(r\"locat\\ ,=ion\").escape(), r\"locat\\\\ \\,\\=ion\");\n\n        assert_eq!(FieldValue(&Type::Boolean(true)).escape(), r#\"true\"#);\n        assert_eq!(FieldValue(&Type::Boolean(false)).escape(), r#\"false\"#);\n\n        assert_eq!(FieldValue(&Type::Float(0.0)).escape(), r#\"0\"#);\n        assert_eq!(FieldValue(&Type::Float(-0.1)).escape(), r#\"-0.1\"#);\n\n        assert_eq!(FieldValue(&Type::SignedInteger(0)).escape(), r#\"0i\"#);\n        assert_eq!(FieldValue(&Type::SignedInteger(83)).escape(), r#\"83i\"#);\n\n        assert_eq!(FieldValue(&Type::UnsignedInteger(0)).escape(), r#\"0i\"#);\n        assert_eq!(FieldValue(&Type::UnsignedInteger(83)).escape(), r#\"83i\"#);\n\n        assert_eq!(FieldValue(&Type::UnsignedInteger(0)).escape_v2(), r#\"0u\"#);\n        assert_eq!(FieldValue(&Type::UnsignedInteger(83)).escape_v2(), r#\"83u\"#);\n\n        assert_eq!(FieldValue(&Type::Text(\"\".into())).escape(), r#\"\"\"\"#);\n        assert_eq!(FieldValue(&Type::Text(\"0\".into())).escape(), r#\"\"0\"\"#);\n        assert_eq!(FieldValue(&Type::Text(\"\\\"\".into())).escape(), r#\"\"\\\"\"\"#);\n        assert_eq!(\n            FieldValue(&Type::Text(r#\"locat\"\\ ,=ion\"#.into())).escape(),\n            r#\"\"locat\\\"\\\\ ,=ion\"\"#\n        );\n    }\n\n    #[test]\n    fn test_empty_tag_value() {\n        // InfluxDB doesn't support empty tag values. But that's a job\n        // of a calling site to validate an entire write request.\n        assert_eq!(TagValue(&Type::Text(\"\".into())).escape(), r#\"\"#);\n    }\n}\n","traces":[{"line":6,"address":[8880672,8880697],"length":1,"stats":{"Line":8}},{"line":7,"address":[9534790,9534320,9534345],"length":1,"stats":{"Line":8}},{"line":8,"address":[9251801,9251776,9252246],"length":1,"stats":{"Line":2}},{"line":9,"address":[9252857,9253302,9252832],"length":1,"stats":{"Line":5}},{"line":20,"address":[8882464],"length":1,"stats":{"Line":4}},{"line":22,"address":[9251187,9251312,9251363],"length":1,"stats":{"Line":12}},{"line":23,"address":[9533239],"length":1,"stats":{"Line":3}},{"line":24,"address":[9251294,9251401,9251345],"length":1,"stats":{"Line":11}},{"line":25,"address":[8882670],"length":1,"stats":{"Line":3}},{"line":26,"address":[9533340],"length":1,"stats":{"Line":4}},{"line":30,"address":[8882768],"length":1,"stats":{"Line":1}},{"line":32,"address":[9251616,9251667,9251491],"length":1,"stats":{"Line":2}},{"line":33,"address":[9251527],"length":1,"stats":{"Line":2}},{"line":34,"address":[9251708,9251649,9251598],"length":1,"stats":{"Line":2}},{"line":35,"address":[9251679],"length":1,"stats":{"Line":1}},{"line":36,"address":[8882923],"length":1,"stats":{"Line":0}},{"line":40,"address":[9250192,9251146,9251140],"length":1,"stats":{"Line":3}},{"line":42,"address":[9532253],"length":1,"stats":{"Line":3}},{"line":43,"address":[9250301],"length":1,"stats":{"Line":1}},{"line":44,"address":[9250662,9250316,9250690],"length":1,"stats":{"Line":3}},{"line":45,"address":[9250664],"length":1,"stats":{"Line":1}},{"line":47,"address":[8881931],"length":1,"stats":{"Line":1}},{"line":51,"address":[8881637],"length":1,"stats":{"Line":1}},{"line":52,"address":[8881664],"length":1,"stats":{"Line":3}},{"line":53,"address":[9250506],"length":1,"stats":{"Line":1}},{"line":54,"address":[9532534],"length":1,"stats":{"Line":1}},{"line":55,"address":[9250850],"length":1,"stats":{"Line":1}},{"line":57,"address":[8882009],"length":1,"stats":{"Line":1}},{"line":60,"address":[8881830,8882271],"length":1,"stats":{"Line":1}},{"line":64,"address":[9531856],"length":1,"stats":{"Line":4}},{"line":66,"address":[9531880],"length":1,"stats":{"Line":4}},{"line":67,"address":[9249928],"length":1,"stats":{"Line":1}},{"line":68,"address":[9531956,9532173,9532145],"length":1,"stats":{"Line":2}},{"line":69,"address":[9532147],"length":1,"stats":{"Line":1}},{"line":71,"address":[9250108],"length":1,"stats":{"Line":0}},{"line":75,"address":[9249965],"length":1,"stats":{"Line":1}},{"line":76,"address":[9249995],"length":1,"stats":{"Line":1}},{"line":77,"address":[9250025],"length":1,"stats":{"Line":3}},{"line":78,"address":[9250050],"length":1,"stats":{"Line":2}},{"line":82,"address":[9249815,9249664,9249821],"length":1,"stats":{"Line":4}},{"line":83,"address":[9249709],"length":1,"stats":{"Line":4}}],"covered":39,"coverable":41},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","query","mod.rs"],"content":"//! Used to create queries of type [`ReadQuery`](crate::query::read_query::ReadQuery) or\n//! [`WriteQuery`](crate::query::write_query::WriteQuery) which can be executed in InfluxDB\n//!\n//! # Examples\n//!\n//! ```rust\n//! use influxdb::{InfluxDbWriteable, Query as _, ReadQuery, Timestamp};\n//!\n//! let write_query = Timestamp::Nanoseconds(0)\n//!     .try_into_query(\"measurement\")\n//!     .unwrap()\n//!     .add_field(\"field1\", 5)\n//!     .add_tag(\"author\", \"Gero\")\n//!     .build();\n//!\n//! assert!(write_query.is_ok());\n//!\n//! let read_query = ReadQuery::new(\"SELECT * FROM weather\").build();\n//!\n//! assert!(read_query.is_ok());\n//! ```\n\npub mod consts;\nmod line_proto_term;\npub mod read_query;\npub mod write_query;\nuse std::convert::Infallible;\nuse std::fmt;\n\nuse crate::{Error, WriteQuery};\nuse consts::{\n    MILLIS_PER_SECOND, MINUTES_PER_HOUR, NANOS_PER_MICRO, NANOS_PER_MILLI, SECONDS_PER_MINUTE,\n};\n\n#[cfg(feature = \"derive\")]\npub use influxdb_derive::InfluxDbWriteable;\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone)]\npub enum Timestamp {\n    Nanoseconds(u128),\n    Microseconds(u128),\n    Milliseconds(u128),\n    Seconds(u128),\n    Minutes(u128),\n    Hours(u128),\n}\n\nimpl Timestamp {\n    pub fn nanos(&self) -> u128 {\n        match self {\n            Timestamp::Hours(h) => {\n                h * MINUTES_PER_HOUR * SECONDS_PER_MINUTE * MILLIS_PER_SECOND * NANOS_PER_MILLI\n            }\n            Timestamp::Minutes(m) => m * SECONDS_PER_MINUTE * MILLIS_PER_SECOND * NANOS_PER_MILLI,\n            Timestamp::Seconds(s) => s * MILLIS_PER_SECOND * NANOS_PER_MILLI,\n            Timestamp::Milliseconds(millis) => millis * NANOS_PER_MILLI,\n            Timestamp::Microseconds(micros) => micros * NANOS_PER_MICRO,\n            Timestamp::Nanoseconds(nanos) => *nanos,\n        }\n    }\n}\n\nimpl fmt::Display for Timestamp {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use Timestamp::*;\n        match self {\n            Nanoseconds(ts) | Microseconds(ts) | Milliseconds(ts) | Seconds(ts) | Minutes(ts)\n            | Hours(ts) => write!(f, \"{ts}\"),\n        }\n    }\n}\n\n#[cfg(feature = \"chrono\")]\nimpl TryFrom<Timestamp> for chrono::DateTime<chrono::Utc> {\n    type Error = <i64 as TryFrom<u128>>::Error;\n\n    fn try_from(ts: Timestamp) -> Result<Self, Self::Error> {\n        use chrono::TimeZone as _;\n        Ok(chrono::Utc.timestamp_nanos(ts.nanos().try_into()?))\n    }\n}\n\n#[cfg(feature = \"chrono\")]\nimpl TryFrom<chrono::DateTime<chrono::Utc>> for Timestamp {\n    type Error = crate::error::TimeTryFromError<\n        crate::error::TimestampTooLargeError,\n        <u128 as TryFrom<i64>>::Error,\n    >;\n\n    fn try_from(dt: chrono::DateTime<chrono::Utc>) -> Result<Self, Self::Error> {\n        // unfortunately chrono doesn't give us the nanos as i128, so we have to error\n        // if it doesn't fit and then cast the i64 to u128 anyways\n        let nanos = dt\n            .timestamp_nanos_opt()\n            .ok_or(Self::Error::TimeError(\n                crate::error::TimestampTooLargeError(()),\n            ))?\n            .try_into()\n            .map_err(Self::Error::IntError)?;\n        Ok(Self::Nanoseconds(nanos))\n    }\n}\n\n#[cfg(feature = \"time\")]\nimpl TryFrom<Timestamp> for time::UtcDateTime {\n    type Error =\n        crate::error::TimeTryFromError<time::error::ComponentRange, <i128 as TryFrom<u128>>::Error>;\n\n    fn try_from(value: Timestamp) -> Result<Self, Self::Error> {\n        let nanos = value.nanos().try_into().map_err(Self::Error::IntError)?;\n        time::UtcDateTime::from_unix_timestamp_nanos(nanos).map_err(Self::Error::TimeError)\n    }\n}\n\n#[cfg(feature = \"time\")]\nimpl TryFrom<time::UtcDateTime> for Timestamp {\n    type Error = <u128 as TryFrom<i128>>::Error;\n\n    fn try_from(value: time::UtcDateTime) -> Result<Self, Self::Error> {\n        Ok(Timestamp::Nanoseconds(\n            value.unix_timestamp_nanos().try_into()?,\n        ))\n    }\n}\n\npub trait Query {\n    /// Builds valid InfluxSQL which can be run against the Database.\n    /// In case no fields have been specified, it will return an error,\n    /// as that is invalid InfluxSQL syntax.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use influxdb::{InfluxDbWriteable, Query, Timestamp};\n    ///\n    /// let invalid_query = Timestamp::Nanoseconds(0)\n    ///     .try_into_query(\"measurement\")\n    ///     .unwrap()\n    ///     .build();\n    /// assert!(invalid_query.is_err());\n    ///\n    /// let valid_query = Timestamp::Nanoseconds(0)\n    ///     .try_into_query(\"measurement\")\n    ///     .unwrap()\n    ///     .add_field(\"myfield1\", 11)\n    ///     .build();\n    /// assert!(valid_query.is_ok());\n    /// ```\n    fn build(&self) -> Result<ValidQuery, Error>;\n\n    /// Like [build] but with additional support for unsigned integers in the line protocol.\n    /// Please note, this crate can only interact with InfluxDB 2.0 in compatibility mode\n    /// and does not natively support InfluxDB 2.0.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use influxdb::{InfluxDbWriteable, Query, Timestamp};\n    ///\n    /// let use_v2 = true;\n    ///\n    /// let invalid_query = Timestamp::Nanoseconds(0)\n    ///     .try_into_query(\"measurement\")\n    ///     .unwrap()\n    ///     .build_with_opts(use_v2);\n    /// assert!(invalid_query.is_err());\n    ///\n    /// let valid_query = Timestamp::Nanoseconds(0)\n    ///     .try_into_query(\"measurement\")\n    ///     .unwrap()\n    ///     .add_field(\"myfield1\", 11)\n    ///     .build_with_opts(use_v2);\n    /// assert!(valid_query.is_ok());\n    /// ```\n    fn build_with_opts(&self, use_v2: bool) -> Result<ValidQuery, Error>;\n\n    fn get_type(&self) -> QueryType;\n}\n\nimpl<Q: Query> Query for &Q {\n    fn build(&self) -> Result<ValidQuery, Error> {\n        Q::build_with_opts(self, false)\n    }\n\n    fn build_with_opts(&self, use_v2: bool) -> Result<ValidQuery, Error> {\n        Q::build_with_opts(self, use_v2)\n    }\n\n    fn get_type(&self) -> QueryType {\n        Q::get_type(self)\n    }\n}\n\nimpl<Q: Query> Query for Box<Q> {\n    fn build(&self) -> Result<ValidQuery, Error> {\n        Q::build(self)\n    }\n\n    fn build_with_opts(&self, use_v2: bool) -> Result<ValidQuery, Error> {\n        Q::build_with_opts(self, use_v2)\n    }\n\n    fn get_type(&self) -> QueryType {\n        Q::get_type(self)\n    }\n}\n\npub trait InfluxDbWriteable {\n    type Error;\n\n    fn try_into_query<I: Into<String>>(self, name: I) -> Result<WriteQuery, Self::Error>;\n}\n\nimpl InfluxDbWriteable for Timestamp {\n    type Error = Infallible;\n\n    fn try_into_query<I: Into<String>>(self, name: I) -> Result<WriteQuery, Infallible> {\n        Ok(WriteQuery::new(self, name.into()))\n    }\n}\n\n#[derive(Debug)]\n#[doc(hidden)]\npub struct ValidQuery(String);\nimpl ValidQuery {\n    pub fn get(self) -> String {\n        self.0\n    }\n}\nimpl<T> From<T> for ValidQuery\nwhere\n    T: Into<String>,\n{\n    fn from(string: T) -> Self {\n        Self(string.into())\n    }\n}\nimpl PartialEq<String> for ValidQuery {\n    fn eq(&self, other: &String) -> bool {\n        &self.0 == other\n    }\n}\nimpl PartialEq<&str> for ValidQuery {\n    fn eq(&self, other: &&str) -> bool {\n        &self.0 == other\n    }\n}\n\n/// Internal Enum used to decide if a `POST` or `GET` request should be sent to InfluxDB. See [InfluxDB Docs](https://docs.influxdata.com/influxdb/v1.7/tools/api/#query-http-endpoint).\n#[derive(PartialEq, Eq, Debug)]\npub enum QueryType {\n    ReadQuery,\n    /// write query with precision\n    WriteQuery(String),\n}\n\n#[cfg(test)]\nmod tests {\n    #[cfg(feature = \"chrono\")]\n    use super::consts::{\n        MILLIS_PER_SECOND, MINUTES_PER_HOUR, NANOS_PER_MICRO, NANOS_PER_MILLI, SECONDS_PER_MINUTE,\n    };\n    use crate::query::{Timestamp, ValidQuery};\n\n    #[test]\n    fn test_equality_str() {\n        assert_eq!(ValidQuery::from(\"hello\"), \"hello\");\n    }\n\n    #[test]\n    fn test_equality_string() {\n        assert_eq!(\n            ValidQuery::from(String::from(\"hello\")),\n            String::from(\"hello\")\n        );\n    }\n\n    #[test]\n    fn test_format_for_timestamp_else() {\n        assert!(format!(\"{}\", Timestamp::Nanoseconds(100)) == \"100\");\n    }\n\n    #[cfg(feature = \"chrono\")]\n    #[test]\n    fn test_chrono_datetime_from_timestamp_hours() {\n        use chrono::prelude::*;\n        let datetime_from_timestamp: DateTime<Utc> = Timestamp::Hours(2).try_into().unwrap();\n        assert_eq!(\n            Utc.timestamp_nanos(\n                (2 * MINUTES_PER_HOUR * SECONDS_PER_MINUTE * MILLIS_PER_SECOND * NANOS_PER_MILLI)\n                    .try_into()\n                    .unwrap()\n            ),\n            datetime_from_timestamp\n        )\n    }\n\n    #[cfg(feature = \"chrono\")]\n    #[test]\n    fn test_chrono_datetime_from_timestamp_minutes() {\n        use chrono::prelude::*;\n        let datetime_from_timestamp: DateTime<Utc> = Timestamp::Minutes(2).try_into().unwrap();\n        assert_eq!(\n            Utc.timestamp_nanos(\n                (2 * SECONDS_PER_MINUTE * MILLIS_PER_SECOND * NANOS_PER_MILLI)\n                    .try_into()\n                    .unwrap()\n            ),\n            datetime_from_timestamp\n        )\n    }\n\n    #[cfg(feature = \"chrono\")]\n    #[test]\n    fn test_chrono_datetime_from_timestamp_seconds() {\n        use chrono::prelude::*;\n        let datetime_from_timestamp: DateTime<Utc> = Timestamp::Seconds(2).try_into().unwrap();\n        assert_eq!(\n            Utc.timestamp_nanos(\n                (2 * MILLIS_PER_SECOND * NANOS_PER_MILLI)\n                    .try_into()\n                    .unwrap()\n            ),\n            datetime_from_timestamp\n        )\n    }\n\n    #[cfg(feature = \"chrono\")]\n    #[test]\n    fn test_chrono_datetime_from_timestamp_millis() {\n        use chrono::prelude::*;\n        let datetime_from_timestamp: DateTime<Utc> = Timestamp::Milliseconds(2).try_into().unwrap();\n        assert_eq!(\n            Utc.timestamp_nanos((2 * NANOS_PER_MILLI).try_into().unwrap()),\n            datetime_from_timestamp\n        )\n    }\n\n    #[cfg(feature = \"chrono\")]\n    #[test]\n    fn test_chrono_datetime_from_timestamp_nanos() {\n        use chrono::prelude::*;\n        let datetime_from_timestamp: DateTime<Utc> = Timestamp::Nanoseconds(1).try_into().unwrap();\n        assert_eq!(Utc.timestamp_nanos(1), datetime_from_timestamp)\n    }\n\n    #[cfg(feature = \"chrono\")]\n    #[test]\n    fn test_chrono_datetime_from_timestamp_micros() {\n        use chrono::prelude::*;\n        let datetime_from_timestamp: DateTime<Utc> = Timestamp::Microseconds(2).try_into().unwrap();\n        assert_eq!(\n            Utc.timestamp_nanos((2 * NANOS_PER_MICRO).try_into().unwrap()),\n            datetime_from_timestamp\n        )\n    }\n\n    #[cfg(feature = \"chrono\")]\n    #[test]\n    fn test_timestamp_from_chrono_date() {\n        use chrono::prelude::*;\n        let timestamp_from_datetime: Timestamp = Utc\n            .with_ymd_and_hms(1970, 1, 1, 0, 0, 1)\n            .single()\n            .unwrap()\n            .try_into()\n            .unwrap();\n        assert_eq!(\n            Timestamp::Nanoseconds(MILLIS_PER_SECOND * NANOS_PER_MILLI),\n            timestamp_from_datetime\n        )\n    }\n}\n","traces":[{"line":49,"address":[8939936],"length":1,"stats":{"Line":4}},{"line":50,"address":[9535399],"length":1,"stats":{"Line":4}},{"line":51,"address":[9253858],"length":1,"stats":{"Line":3}},{"line":52,"address":[9254353,9253870,9254178],"length":1,"stats":{"Line":6}},{"line":54,"address":[8940630,8940313],"length":1,"stats":{"Line":2}},{"line":55,"address":[9535620,9536026],"length":1,"stats":{"Line":2}},{"line":56,"address":[9253542],"length":1,"stats":{"Line":1}},{"line":57,"address":[9253480],"length":1,"stats":{"Line":1}},{"line":58,"address":[8940004],"length":1,"stats":{"Line":2}},{"line":64,"address":[9520688],"length":1,"stats":{"Line":4}},{"line":66,"address":[9238799,9238739,9238695,9238754,9238769,9238784],"length":1,"stats":{"Line":7}},{"line":67,"address":[9238760,9238730,9238775,9238790,9238745],"length":1,"stats":{"Line":5}},{"line":77,"address":[9601104],"length":1,"stats":{"Line":4}},{"line":79,"address":[9601137],"length":1,"stats":{"Line":4}},{"line":90,"address":[9507424],"length":1,"stats":{"Line":2}},{"line":93,"address":[9507530,9507476,9507687,9507633],"length":1,"stats":{"Line":4}},{"line":95,"address":[9507463],"length":1,"stats":{"Line":2}},{"line":99,"address":[9507619,9507671],"length":1,"stats":{"Line":2}},{"line":100,"address":[9507742],"length":1,"stats":{"Line":2}},{"line":109,"address":[9302944],"length":1,"stats":{"Line":0}},{"line":110,"address":[9302980],"length":1,"stats":{"Line":0}},{"line":111,"address":[9585239],"length":1,"stats":{"Line":0}},{"line":119,"address":[9222912],"length":1,"stats":{"Line":0}},{"line":120,"address":[9223060],"length":1,"stats":{"Line":0}},{"line":121,"address":[9222928],"length":1,"stats":{"Line":0}},{"line":181,"address":[8787632],"length":1,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[8787680],"length":1,"stats":{"Line":2}},{"line":190,"address":[8787697],"length":1,"stats":{"Line":2}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":6}},{"line":226,"address":[9530816],"length":1,"stats":{"Line":6}},{"line":227,"address":[9248803],"length":1,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[8945872],"length":1,"stats":{"Line":1}},{"line":240,"address":[9254637],"length":1,"stats":{"Line":1}},{"line":244,"address":[9244688],"length":1,"stats":{"Line":1}},{"line":245,"address":[9244701],"length":1,"stats":{"Line":1}}],"covered":33,"coverable":47},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","query","read_query.rs"],"content":"//! Read Query Builder\n\nuse crate::query::{QueryType, ValidQuery};\nuse crate::{Error, Query};\n\n#[derive(Debug, Clone)]\npub struct ReadQuery {\n    queries: Vec<String>,\n}\n\nimpl ReadQuery {\n    /// Creates a new [`ReadQuery`]\n    #[must_use = \"Creating a query is pointless unless you execute it\"]\n    pub fn new<S>(query: S) -> Self\n    where\n        S: Into<String>,\n    {\n        ReadQuery {\n            queries: vec![query.into()],\n        }\n    }\n\n    /// Adds a query to the [`ReadQuery`]\n    #[must_use = \"Creating a query is pointless unless you execute it\"]\n    pub fn add_query<S>(mut self, query: S) -> Self\n    where\n        S: Into<String>,\n    {\n        self.queries.push(query.into());\n        self\n    }\n}\n\nimpl Query for ReadQuery {\n    fn build(&self) -> Result<ValidQuery, Error> {\n        Ok(ValidQuery(self.queries.join(\";\")))\n    }\n\n    fn build_with_opts(&self, _use_v2: bool) -> Result<ValidQuery, Error> {\n        Ok(ValidQuery(self.queries.join(\";\")))\n    }\n\n    fn get_type(&self) -> QueryType {\n        QueryType::ReadQuery\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ReadQuery;\n    use crate::query::{Query, QueryType};\n\n    #[test]\n    fn test_read_builder_single_query() {\n        let query = ReadQuery::new(\"SELECT * FROM aachen\").build();\n\n        assert_eq!(query.unwrap(), \"SELECT * FROM aachen\");\n    }\n\n    #[test]\n    fn test_read_builder_multi_query() {\n        let query = ReadQuery::new(\"SELECT * FROM aachen\")\n            .add_query(\"SELECT * FROM cologne\")\n            .build();\n\n        assert_eq!(query.unwrap(), \"SELECT * FROM aachen;SELECT * FROM cologne\");\n    }\n\n    #[test]\n    fn test_correct_query_type() {\n        let query = ReadQuery::new(\"SELECT * FROM aachen\");\n\n        assert_eq!(query.get_type(), QueryType::ReadQuery);\n    }\n}\n","traces":[{"line":14,"address":[8741280,8741291,8740512,8740873,8740884,8740912],"length":1,"stats":{"Line":6}},{"line":19,"address":[],"length":0,"stats":{"Line":11}},{"line":25,"address":[9063501,9063328],"length":1,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[9063474],"length":1,"stats":{"Line":2}},{"line":35,"address":[9296320],"length":1,"stats":{"Line":5}},{"line":36,"address":[9296352],"length":1,"stats":{"Line":4}},{"line":39,"address":[9296160],"length":1,"stats":{"Line":0}},{"line":40,"address":[9296198],"length":1,"stats":{"Line":0}},{"line":43,"address":[9296464],"length":1,"stats":{"Line":5}},{"line":44,"address":[9296472],"length":1,"stats":{"Line":3}}],"covered":9,"coverable":11},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","src","query","write_query.rs"],"content":"//! Write Query Builder returned by Query::write_query\n//!\n//! Can only be instantiated by using Query::write_query\n\nuse crate::query::line_proto_term::LineProtoTerm;\nuse crate::query::{QueryType, ValidQuery};\nuse crate::{Error, Query, Timestamp};\nuse std::fmt::{Display, Formatter};\n\npub trait WriteType {\n    fn add_to(self, tag: String, fields_or_tags: &mut Vec<(String, Type)>);\n}\n\nimpl<T: Into<Type>> WriteType for T {\n    fn add_to(self, tag: String, fields_or_tags: &mut Vec<(String, Type)>) {\n        let val: Type = self.into();\n        fields_or_tags.push((tag, val));\n    }\n}\n\nimpl<T: Into<Type>> WriteType for Option<T> {\n    fn add_to(self, tag: String, fields_or_tags: &mut Vec<(String, Type)>) {\n        if let Some(val) = self {\n            val.add_to(tag, fields_or_tags);\n        }\n    }\n}\n\n/// Internal Representation of a Write query that has not yet been built\n#[derive(Debug, Clone)]\npub struct WriteQuery {\n    fields: Vec<(String, Type)>,\n    tags: Vec<(String, Type)>,\n    measurement: String,\n    timestamp: Timestamp,\n}\n\nimpl WriteQuery {\n    /// Creates a new [`WriteQuery`](crate::query::write_query::WriteQuery)\n    #[must_use = \"Creating a query is pointless unless you execute it\"]\n    pub fn new<S>(timestamp: Timestamp, measurement: S) -> Self\n    where\n        S: Into<String>,\n    {\n        WriteQuery {\n            fields: vec![],\n            tags: vec![],\n            measurement: measurement.into(),\n            timestamp,\n        }\n    }\n\n    /// Adds a field to the [`WriteQuery`](crate::WriteQuery)\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use influxdb::{InfluxDbWriteable, Query, Timestamp};\n    ///\n    /// Timestamp::Nanoseconds(0)\n    ///     .try_into_query(\"measurement\")\n    ///     .unwrap()\n    ///     .add_field(\"field1\", 5)\n    ///     .build();\n    /// ```\n    #[must_use = \"Creating a query is pointless unless you execute it\"]\n    pub fn add_field<S, F>(mut self, field: S, value: F) -> Self\n    where\n        S: Into<String>,\n        F: WriteType,\n    {\n        value.add_to(field.into(), &mut self.fields);\n        self\n    }\n\n    /// Adds a tag to the [`WriteQuery`](crate::WriteQuery)\n    ///\n    /// Please note that a [`WriteQuery`](crate::WriteQuery) requires at least one field. Composing a query with\n    /// only tags will result in a failure building the query.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use influxdb::{Query, Timestamp};\n    /// use influxdb::InfluxDbWriteable;\n    ///\n    /// Timestamp::Nanoseconds(0)\n    ///     .try_into_query(\"measurement\").unwrap()\n    ///     .add_tag(\"field1\", 5); // calling `.build()` now would result in a `Err(Error::InvalidQueryError)`\n    /// ```\n    #[must_use = \"Creating a query is pointless unless you execute it\"]\n    pub fn add_tag<S, I>(mut self, tag: S, value: I) -> Self\n    where\n        S: Into<String>,\n        I: WriteType,\n    {\n        value.add_to(tag.into(), &mut self.tags);\n        self\n    }\n\n    pub fn get_precision(&self) -> String {\n        let modifier = match self.timestamp {\n            Timestamp::Nanoseconds(_) => \"ns\",\n            Timestamp::Microseconds(_) => \"u\",\n            Timestamp::Milliseconds(_) => \"ms\",\n            Timestamp::Seconds(_) => \"s\",\n            Timestamp::Minutes(_) => \"m\",\n            Timestamp::Hours(_) => \"h\",\n        };\n        modifier.to_string()\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum Type {\n    Boolean(bool),\n    Float(f64),\n    SignedInteger(i64),\n    UnsignedInteger(u64),\n    Text(String),\n}\n\nimpl Display for Type {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        use Type::*;\n\n        match self {\n            Boolean(x) => write!(f, \"{x}\"),\n            Float(x) => write!(f, \"{x}\"),\n            SignedInteger(x) => write!(f, \"{x}\"),\n            UnsignedInteger(x) => write!(f, \"{x}\"),\n            Text(text) => write!(f, \"{text}\"),\n        }\n    }\n}\n\nmacro_rules! from_impl {\n        ( $variant:ident => $( $typ:ident ),+ ) => (\n                $(\n                    impl From<$typ> for Type {\n                        fn from(b: $typ) -> Self {\n                            Type::$variant(b.into())\n                        }\n                    }\n                )+\n        )\n}\nfrom_impl! {Boolean => bool}\nfrom_impl! {Float => f32, f64}\nfrom_impl! {SignedInteger => i8, i16, i32, i64}\nfrom_impl! {UnsignedInteger => u8, u16, u32, u64}\nfrom_impl! {Text => String}\nimpl From<&str> for Type {\n    fn from(b: &str) -> Self {\n        Type::Text(b.into())\n    }\n}\n\n#[cfg(feature = \"chrono\")]\nimpl TryFrom<chrono::DateTime<chrono::Utc>> for Type {\n    type Error = crate::error::TimestampTooLargeError;\n\n    fn try_from(dt: chrono::DateTime<chrono::Utc>) -> Result<Self, Self::Error> {\n        let nanos = dt\n            .timestamp_nanos_opt()\n            .ok_or(crate::error::TimestampTooLargeError(()))?;\n        Ok(Self::SignedInteger(nanos))\n    }\n}\n\n#[cfg(feature = \"time\")]\nimpl TryFrom<time::UtcDateTime> for Type {\n    type Error = <i64 as TryFrom<i128>>::Error;\n\n    fn try_from(dt: time::UtcDateTime) -> Result<Self, Self::Error> {\n        let nanos = dt.unix_timestamp_nanos().try_into()?;\n        Ok(Self::SignedInteger(nanos))\n    }\n}\n\nimpl<T> From<&T> for Type\nwhere\n    T: Copy + Into<Type>,\n{\n    fn from(t: &T) -> Self {\n        (*t).into()\n    }\n}\n\nimpl Query for WriteQuery {\n    fn build(&self) -> Result<ValidQuery, Error> {\n        self.build_with_opts(false)\n    }\n\n    fn build_with_opts(&self, use_v2: bool) -> Result<ValidQuery, Error> {\n        if self.fields.is_empty() {\n            return Err(Error::InvalidQueryError {\n                error: \"fields cannot be empty\".to_string(),\n            });\n        }\n\n        let mut tags = self\n            .tags\n            .iter()\n            .map(|(tag, value)| {\n                let escaped_tag_key = if use_v2 {\n                    LineProtoTerm::TagKey(tag).escape_v2()\n                } else {\n                    LineProtoTerm::TagKey(tag).escape()\n                };\n                let escaped_tag_value = if use_v2 {\n                    LineProtoTerm::TagValue(value).escape_v2()\n                } else {\n                    LineProtoTerm::TagValue(value).escape()\n                };\n                format!(\"{escaped_tag_key}={escaped_tag_value}\")\n            })\n            .collect::<Vec<String>>()\n            .join(\",\");\n\n        if !tags.is_empty() {\n            tags.insert(0, ',');\n        }\n        let fields = self\n            .fields\n            .iter()\n            .map(|(field, value)| {\n                let escaped_field_key = if use_v2 {\n                    LineProtoTerm::FieldKey(field).escape_v2()\n                } else {\n                    LineProtoTerm::FieldKey(field).escape()\n                };\n                let escaped_field_value = if use_v2 {\n                    LineProtoTerm::FieldValue(value).escape_v2()\n                } else {\n                    LineProtoTerm::FieldValue(value).escape()\n                };\n                format!(\"{escaped_field_key}={escaped_field_value}\")\n            })\n            .collect::<Vec<String>>()\n            .join(\",\");\n\n        let escaped_measurement = if use_v2 {\n            LineProtoTerm::Measurement(&self.measurement).escape_v2()\n        } else {\n            LineProtoTerm::Measurement(&self.measurement).escape()\n        };\n\n        Ok(ValidQuery(format!(\n            \"{measurement}{tags} {fields} {time}\",\n            measurement = escaped_measurement,\n            tags = tags,\n            fields = fields,\n            time = self.timestamp\n        )))\n    }\n\n    fn get_type(&self) -> QueryType {\n        QueryType::WriteQuery(self.get_precision())\n    }\n}\n\nimpl Query for Vec<WriteQuery> {\n    fn build(&self) -> Result<ValidQuery, Error> {\n        let mut qlines = Vec::new();\n\n        for q in self {\n            let valid_query = q.build()?;\n            qlines.push(valid_query.0);\n        }\n\n        Ok(ValidQuery(qlines.join(\"\\n\")))\n    }\n\n    fn build_with_opts(&self, use_v2: bool) -> Result<ValidQuery, Error> {\n        let mut qlines = Vec::new();\n\n        for q in self {\n            let valid_query = q.build_with_opts(use_v2)?;\n            qlines.push(valid_query.0);\n        }\n\n        Ok(ValidQuery(qlines.join(\"\\n\")))\n    }\n\n    fn get_type(&self) -> QueryType {\n        QueryType::WriteQuery(\n            self.first()\n                .map(|q| q.get_precision())\n                // use \"ms\" as placeholder if query is empty\n                .unwrap_or_else(|| \"ms\".to_owned()),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::query::{InfluxDbWriteable, Query, Timestamp};\n\n    #[test]\n    fn test_write_builder_empty_query() {\n        let query = Timestamp::Hours(5)\n            .try_into_query(\"marina_3\".to_string())\n            .unwrap()\n            .build();\n\n        assert!(query.is_err(), \"Query was not empty\");\n    }\n\n    #[test]\n    fn test_write_builder_single_field() {\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"weather\".to_string())\n            .unwrap()\n            .add_field(\"temperature\", 82)\n            .build();\n\n        assert!(query.is_ok(), \"Query was empty\");\n        assert_eq!(query.unwrap(), \"weather temperature=82i 11\");\n    }\n\n    #[test]\n    fn test_write_builder_multiple_fields() {\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"weather\".to_string())\n            .unwrap()\n            .add_field(\"temperature\", 82)\n            .add_field(\"wind_strength\", 3.7)\n            .add_field(\"temperature_unsigned\", 82u64)\n            .build();\n\n        assert!(query.is_ok(), \"Query was empty\");\n        assert_eq!(\n            query.unwrap(),\n            \"weather temperature=82i,wind_strength=3.7,temperature_unsigned=82i 11\"\n        );\n    }\n\n    #[test]\n    fn test_write_builder_multiple_fields_with_v2() {\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"weather\".to_string())\n            .unwrap()\n            .add_field(\"temperature\", 82)\n            .add_field(\"wind_strength\", 3.7)\n            .add_field(\"temperature_unsigned\", 82u64)\n            .build_with_opts(true);\n\n        assert!(query.is_ok(), \"Query was empty\");\n        assert_eq!(\n            query.unwrap(),\n            \"weather temperature=82i,wind_strength=3.7,temperature_unsigned=82u 11\"\n        );\n    }\n\n    #[test]\n    fn test_write_builder_optional_fields() {\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"weather\".to_string())\n            .unwrap()\n            .add_field(\"temperature\", 82u64)\n            .add_tag(\"wind_strength\", <Option<u64>>::None)\n            .build();\n\n        assert!(query.is_ok(), \"Query was empty\");\n        assert_eq!(query.unwrap(), \"weather temperature=82i 11\");\n    }\n\n    #[test]\n    fn test_write_builder_optional_fields_with_v2() {\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"weather\".to_string())\n            .unwrap()\n            .add_field(\"temperature\", 82u64)\n            .add_tag(\"wind_strength\", <Option<u64>>::None)\n            .build_with_opts(true);\n\n        assert!(query.is_ok(), \"Query was empty\");\n        assert_eq!(query.unwrap(), \"weather temperature=82u 11\");\n    }\n\n    #[test]\n    fn test_write_builder_only_tags() {\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"weather\".to_string())\n            .unwrap()\n            .add_tag(\"season\", \"summer\")\n            .build();\n\n        assert!(query.is_err(), \"Query missing one or more fields\");\n    }\n\n    #[test]\n    fn test_write_builder_full_query() {\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"weather\".to_string())\n            .unwrap()\n            .add_field(\"temperature\", 82)\n            .add_tag(\"location\", \"us-midwest\")\n            .add_tag(\"season\", \"summer\")\n            .build();\n\n        assert!(query.is_ok(), \"Query was empty\");\n        assert_eq!(\n            query.unwrap(),\n            r#\"weather,location=us-midwest,season=summer temperature=82i 11\"#\n        );\n    }\n\n    #[test]\n    fn test_correct_query_type() {\n        use crate::query::QueryType;\n\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"weather\".to_string())\n            .unwrap()\n            .add_field(\"temperature\", 82)\n            .add_tag(\"location\", \"us-midwest\")\n            .add_tag(\"season\", \"summer\");\n\n        assert_eq!(query.get_type(), QueryType::WriteQuery(\"h\".to_owned()));\n    }\n\n    #[test]\n    fn test_escaping() {\n        let query = Timestamp::Hours(11)\n            .try_into_query(\"wea, ther=\")\n            .unwrap()\n            .add_field(\"temperature\", 82)\n            .add_field(\"\\\"temp=era,t ure\\\"\", r#\"too\"\\\\hot\"#)\n            .add_field(\"float\", 82.0)\n            .add_tag(\"location\", \"us-midwest\")\n            .add_tag(\"loc, =\\\"ation\", r#\"us, \"mid=west\"#)\n            .build();\n\n        assert!(query.is_ok(), \"Query was empty\");\n        let query_res = query.unwrap().get();\n        assert_eq!(\n            query_res,\n            r#\"wea\\,\\ ther=,location=us-midwest,loc\\,\\ \\=\"ation=us\\,\\ \\\"mid\\=west temperature=82i,\"temp\\=era\\,t\\ ure\"=\"too\\\"\\\\\\\\hot\",float=82 11\"#\n        );\n    }\n\n    #[test]\n    fn test_batch() {\n        let q0 = Timestamp::Hours(11)\n            .try_into_query(\"weather\")\n            .unwrap()\n            .add_field(\"temperature\", 82)\n            .add_tag(\"location\", \"us-midwest\");\n\n        let q1 = Timestamp::Hours(12)\n            .try_into_query(\"weather\")\n            .unwrap()\n            .add_field(\"temperature\", 65)\n            .add_tag(\"location\", \"us-midwest\");\n\n        let query = vec![q0, q1].build();\n\n        assert_eq!(\n            query.unwrap().get(),\n            r#\"weather,location=us-midwest temperature=82i 11\nweather,location=us-midwest temperature=65i 12\"#\n        );\n    }\n}\n","traces":[{"line":15,"address":[9039516,9039230,9039259,9039019,9039487,9039280,9038784,9038990,9039040],"length":1,"stats":{"Line":12}},{"line":16,"address":[],"length":0,"stats":{"Line":12}},{"line":17,"address":[],"length":0,"stats":{"Line":11}},{"line":22,"address":[8758032],"length":1,"stats":{"Line":5}},{"line":23,"address":[9062301],"length":1,"stats":{"Line":5}},{"line":24,"address":[8758102],"length":1,"stats":{"Line":2}},{"line":41,"address":[9040579,9040176],"length":1,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":47,"address":[8853715],"length":1,"stats":{"Line":4}},{"line":48,"address":[8853760],"length":1,"stats":{"Line":5}},{"line":67,"address":[8805520,8805726],"length":1,"stats":{"Line":9}},{"line":72,"address":[],"length":0,"stats":{"Line":8}},{"line":73,"address":[8805688],"length":1,"stats":{"Line":8}},{"line":92,"address":[9040853,9040624],"length":1,"stats":{"Line":5}},{"line":97,"address":[9040851,9040701],"length":1,"stats":{"Line":5}},{"line":98,"address":[8805452],"length":1,"stats":{"Line":5}},{"line":101,"address":[9530848],"length":1,"stats":{"Line":4}},{"line":102,"address":[9530867],"length":1,"stats":{"Line":4}},{"line":103,"address":[9530898],"length":1,"stats":{"Line":2}},{"line":104,"address":[9530921],"length":1,"stats":{"Line":0}},{"line":105,"address":[8853440],"length":1,"stats":{"Line":0}},{"line":106,"address":[9248951],"length":1,"stats":{"Line":0}},{"line":107,"address":[8853486],"length":1,"stats":{"Line":0}},{"line":108,"address":[9531013],"length":1,"stats":{"Line":2}},{"line":110,"address":[9531039],"length":1,"stats":{"Line":4}},{"line":124,"address":[9240624],"length":1,"stats":{"Line":0}},{"line":127,"address":[9240657],"length":1,"stats":{"Line":0}},{"line":128,"address":[9522737],"length":1,"stats":{"Line":0}},{"line":129,"address":[9240826],"length":1,"stats":{"Line":0}},{"line":130,"address":[8841634],"length":1,"stats":{"Line":0}},{"line":131,"address":[9523070],"length":1,"stats":{"Line":0}},{"line":132,"address":[9523199],"length":1,"stats":{"Line":0}},{"line":141,"address":[9248432,9248352,9247904,9247968,9248272,9248512,9247744,9248112,9247824,9222800,9248032,9248192],"length":1,"stats":{"Line":8}},{"line":142,"address":[9248053,9247764,9247923,9248293,9247987,9248381,9247844,9248141,9248464,9248224,9222814,9248537],"length":1,"stats":{"Line":9}},{"line":154,"address":[9530720],"length":1,"stats":{"Line":2}},{"line":155,"address":[8846887],"length":1,"stats":{"Line":3}},{"line":163,"address":[9508480],"length":1,"stats":{"Line":0}},{"line":164,"address":[9508531],"length":1,"stats":{"Line":0}},{"line":166,"address":[9508519],"length":1,"stats":{"Line":0}},{"line":167,"address":[9226577],"length":1,"stats":{"Line":0}},{"line":175,"address":[8813968],"length":1,"stats":{"Line":0}},{"line":176,"address":[8813982],"length":1,"stats":{"Line":0}},{"line":177,"address":[9507354],"length":1,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[9529616],"length":1,"stats":{"Line":4}},{"line":192,"address":[8845873],"length":1,"stats":{"Line":4}},{"line":195,"address":[9246318,9246324,9244736],"length":1,"stats":{"Line":4}},{"line":196,"address":[8843101],"length":1,"stats":{"Line":4}},{"line":197,"address":[8843263],"length":1,"stats":{"Line":1}},{"line":198,"address":[9526962],"length":1,"stats":{"Line":1}},{"line":202,"address":[8843199,8843122],"length":1,"stats":{"Line":7}},{"line":205,"address":[9528962,9528968,9526870,9528368,9528411],"length":1,"stats":{"Line":12}},{"line":206,"address":[8844676],"length":1,"stats":{"Line":5}},{"line":207,"address":[9528495],"length":1,"stats":{"Line":0}},{"line":209,"address":[9246433],"length":1,"stats":{"Line":4}},{"line":211,"address":[9528539],"length":1,"stats":{"Line":5}},{"line":212,"address":[8844840,8844974],"length":1,"stats":{"Line":0}},{"line":214,"address":[9528684,9528552],"length":1,"stats":{"Line":9}},{"line":216,"address":[8844931,8845017],"length":1,"stats":{"Line":9}},{"line":221,"address":[9245253],"length":1,"stats":{"Line":3}},{"line":222,"address":[9527290,9527354],"length":1,"stats":{"Line":7}},{"line":224,"address":[8843596,8843702],"length":1,"stats":{"Line":7}},{"line":227,"address":[8845832,8845826,8843672,8845232,8845275],"length":1,"stats":{"Line":10}},{"line":228,"address":[8845300],"length":1,"stats":{"Line":4}},{"line":229,"address":[8845359],"length":1,"stats":{"Line":1}},{"line":231,"address":[9529073],"length":1,"stats":{"Line":3}},{"line":233,"address":[8845403],"length":1,"stats":{"Line":3}},{"line":234,"address":[9529224,9529358],"length":1,"stats":{"Line":2}},{"line":236,"address":[9529176,9529308],"length":1,"stats":{"Line":7}},{"line":238,"address":[9529315,9529401],"length":1,"stats":{"Line":6}},{"line":243,"address":[9527629],"length":1,"stats":{"Line":3}},{"line":244,"address":[9527864,9527676],"length":1,"stats":{"Line":4}},{"line":246,"address":[8843961,8843898],"length":1,"stats":{"Line":7}},{"line":249,"address":[8844030,8844215],"length":1,"stats":{"Line":9}},{"line":258,"address":[9529664],"length":1,"stats":{"Line":4}},{"line":259,"address":[9247667],"length":1,"stats":{"Line":4}},{"line":264,"address":[9146913,9146144,9146943],"length":1,"stats":{"Line":1}},{"line":265,"address":[9146174],"length":1,"stats":{"Line":1}},{"line":267,"address":[9146201,9146273,9146889],"length":1,"stats":{"Line":3}},{"line":268,"address":[9146561,9146355],"length":1,"stats":{"Line":2}},{"line":269,"address":[9146783],"length":1,"stats":{"Line":1}},{"line":272,"address":[9146377],"length":1,"stats":{"Line":1}},{"line":275,"address":[9481557,9481587,9480752],"length":1,"stats":{"Line":0}},{"line":276,"address":[9480797],"length":1,"stats":{"Line":0}},{"line":278,"address":[9480896,9480824,9481530],"length":1,"stats":{"Line":0}},{"line":279,"address":[9145526,9145740],"length":1,"stats":{"Line":0}},{"line":280,"address":[9145965],"length":1,"stats":{"Line":0}},{"line":283,"address":[9481010],"length":1,"stats":{"Line":0}},{"line":286,"address":[9146960],"length":1,"stats":{"Line":0}},{"line":288,"address":[9146992],"length":1,"stats":{"Line":0}},{"line":289,"address":[9147013],"length":1,"stats":{"Line":0}},{"line":291,"address":[9147024],"length":1,"stats":{"Line":0}}],"covered":61,"coverable":93},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","tests","derive_integration_tests.rs"],"content":"#[path = \"./utilities.rs\"]\nmod utilities;\n\n#[cfg(feature = \"derive\")]\nuse influxdb::InfluxDbWriteable;\n\nuse chrono::{DateTime, Utc};\nuse influxdb::{Query, ReadQuery, Timestamp};\n\n#[cfg(feature = \"serde\")]\nuse serde_derive::Deserialize;\n\nuse utilities::{assert_result_ok, create_client, create_db, delete_db, run_test};\n\n#[derive(Debug, PartialEq)]\n#[cfg_attr(feature = \"derive\", derive(InfluxDbWriteable))]\nstruct WeatherReading {\n    time: DateTime<Utc>,\n    #[influxdb(ignore)]\n    humidity: i32,\n    pressure: i32,\n    #[influxdb(tag)]\n    wind_strength: Option<u64>,\n}\n\n#[derive(Debug, PartialEq)]\n#[cfg_attr(feature = \"derive\", derive(InfluxDbWriteable))]\nstruct WeatherReadingWithNonstandardTime {\n    #[influxdb(time)]\n    reading_time: DateTime<Utc>,\n    #[influxdb(ignore)]\n    time: DateTime<Utc>,\n    #[influxdb(ignore)]\n    humidity: i32,\n    pressure: i32,\n    #[influxdb(tag)]\n    wind_strength: Option<u64>,\n}\n\n#[derive(Debug)]\n#[cfg_attr(feature = \"serde\", derive(Deserialize))]\nstruct WeatherReadingWithoutIgnored {\n    time: DateTime<Utc>,\n    pressure: i32,\n    wind_strength: Option<u64>,\n}\n\n#[test]\nfn test_build_query() {\n    let weather_reading = WeatherReading {\n        time: Timestamp::Hours(1).try_into().unwrap(),\n        humidity: 30,\n        pressure: 100,\n        wind_strength: Some(5),\n    };\n    let query = weather_reading\n        .try_into_query(\"weather_reading\")\n        .unwrap()\n        .build()\n        .unwrap();\n    assert_eq!(\n        query.get(),\n        \"weather_reading,wind_strength=5 pressure=100i 3600000000000\"\n    );\n}\n\n#[test]\nfn test_build_nonstandard_query() {\n    let weather_reading = WeatherReadingWithNonstandardTime {\n        reading_time: Timestamp::Hours(1).try_into().unwrap(),\n        time: Timestamp::Hours(1).try_into().unwrap(),\n        humidity: 30,\n        pressure: 100,\n        wind_strength: Some(5),\n    };\n    let query = weather_reading\n        .try_into_query(\"weather_reading\")\n        .unwrap()\n        .build()\n        .unwrap();\n    assert_eq!(\n        query.get(),\n        \"weather_reading,wind_strength=5 pressure=100i 3600000000000\"\n    );\n}\n\n#[cfg(feature = \"derive\")]\n/// INTEGRATION TEST\n///\n/// This integration tests that writing data and retrieving the data again is working\n#[tokio::test]\n#[cfg(not(tarpaulin_include))]\nasync fn test_derive_simple_write() {\n    const TEST_NAME: &str = \"test_derive_simple_write\";\n\n    run_test(\n        || async move {\n            create_db(TEST_NAME).await.expect(\"could not setup db\");\n            let client = create_client(TEST_NAME);\n            let weather_reading = WeatherReading {\n                time: Timestamp::Nanoseconds(0).try_into().unwrap(),\n                humidity: 30,\n                wind_strength: Some(5),\n                pressure: 100,\n            };\n            let query = weather_reading.try_into_query(\"weather_reading\").unwrap();\n            let result = client.query(&query).await;\n            assert!(result.is_ok(), \"unable to insert into db\");\n        },\n        || async move {\n            delete_db(TEST_NAME).await.expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This integration tests that writing data and retrieving the data again is working\n#[cfg(feature = \"derive\")]\n#[cfg(feature = \"serde\")]\n#[tokio::test]\n#[cfg(not(tarpaulin_include))]\nasync fn test_write_and_read_option() {\n    const TEST_NAME: &str = \"test_write_and_read_option\";\n\n    run_test(\n        || async move {\n            create_db(TEST_NAME).await.expect(\"could not setup db\");\n            let client = create_client(TEST_NAME);\n            let weather_reading = WeatherReading {\n                time: Timestamp::Hours(11).try_into().unwrap(),\n                humidity: 30,\n                wind_strength: None,\n                pressure: 100,\n            };\n            let write_result = client\n                .query(\n                    &weather_reading\n                        .try_into_query(\"weather_reading\".to_string())\n                        .unwrap(),\n                )\n                .await;\n            assert_result_ok(&write_result);\n\n            let query = ReadQuery::new(\"SELECT time, pressure, wind_strength FROM weather_reading\");\n            let result = client.json_query(query).await.and_then(|mut db_result| {\n                println!(\"{db_result:?}\");\n                db_result.deserialize_next::<WeatherReadingWithoutIgnored>()\n            });\n            assert_result_ok(&result);\n            let result = result.unwrap();\n            let value = &result.series[0].values[0];\n            assert_eq!(value.time, Timestamp::Hours(11).try_into().unwrap());\n            assert_eq!(value.pressure, 100);\n            assert_eq!(value.wind_strength, None);\n        },\n        || async move {\n            delete_db(TEST_NAME).await.expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n","traces":[{"line":1,"address":[8845424],"length":1,"stats":{"Line":1}},{"line":15,"address":[8852768,8852837,8855976,8855872],"length":1,"stats":{"Line":0}},{"line":16,"address":[8832688,8835600,8835612,8826562,8831306,8832736,8831280,8835584,8826544],"length":1,"stats":{"Line":4}},{"line":18,"address":[8852811,8855936],"length":1,"stats":{"Line":0}},{"line":20,"address":[8852818,8855895],"length":1,"stats":{"Line":0}},{"line":21,"address":[8855919,8852825],"length":1,"stats":{"Line":0}},{"line":23,"address":[8855964,8855903,8852832],"length":1,"stats":{"Line":0}},{"line":26,"address":[8826304,8856288,8856192,8826436],"length":1,"stats":{"Line":0}},{"line":27,"address":[8826448,8826466,8834176,8834224,8835568,8835616,8835628],"length":1,"stats":{"Line":2}},{"line":30,"address":[8856244,8826368],"length":1,"stats":{"Line":0}},{"line":32,"address":[8826396,8856251],"length":1,"stats":{"Line":0}},{"line":34,"address":[8826327,8856266],"length":1,"stats":{"Line":0}},{"line":35,"address":[8856273,8826351],"length":1,"stats":{"Line":0}},{"line":37,"address":[8826335,8826424,8856280],"length":1,"stats":{"Line":0}},{"line":40,"address":[8856000,8856053],"length":1,"stats":{"Line":0}},{"line":41,"address":[8829808,8829964,8829692,8834080,8829978,8827728,8829917,8827664,8829769,8829744,8834091,8827750,8829992,8829680,8827689],"length":1,"stats":{"Line":10}},{"line":43,"address":[8856034,8829858],"length":1,"stats":{"Line":1}},{"line":44,"address":[8856041,8829889],"length":1,"stats":{"Line":1}},{"line":45,"address":[8829936,8856048],"length":1,"stats":{"Line":1}},{"line":49,"address":[8831181,8831250,8830016,8831232,8831187],"length":1,"stats":{"Line":3}},{"line":50,"address":[8830023,8830186],"length":1,"stats":{"Line":2}},{"line":51,"address":[8830051],"length":1,"stats":{"Line":1}},{"line":56,"address":[8830238],"length":1,"stats":{"Line":1}},{"line":57,"address":[8830277],"length":1,"stats":{"Line":1}},{"line":59,"address":[8830563],"length":1,"stats":{"Line":1}},{"line":60,"address":[8830878,8830590],"length":1,"stats":{"Line":1}},{"line":61,"address":[8831015],"length":1,"stats":{"Line":1}},{"line":62,"address":[8830946],"length":1,"stats":{"Line":1}},{"line":65,"address":[8831165,8831269,8831202,8830905],"length":1,"stats":{"Line":2}},{"line":68,"address":[8845376,8843968,8845324,8845394,8845330],"length":1,"stats":{"Line":3}},{"line":69,"address":[8843975,8844296],"length":1,"stats":{"Line":2}},{"line":70,"address":[8844003],"length":1,"stats":{"Line":1}},{"line":71,"address":[8844158],"length":1,"stats":{"Line":1}},{"line":76,"address":[8844366],"length":1,"stats":{"Line":1}},{"line":77,"address":[8844405],"length":1,"stats":{"Line":1}},{"line":79,"address":[8844691],"length":1,"stats":{"Line":1}},{"line":80,"address":[8845015,8844718],"length":1,"stats":{"Line":1}},{"line":81,"address":[8845158],"length":1,"stats":{"Line":1}},{"line":82,"address":[8845083],"length":1,"stats":{"Line":1}},{"line":85,"address":[8845308,8845042,8845345,8845413],"length":1,"stats":{"Line":2}},{"line":91,"address":[8836144,8835741,8836169,8836553,8836362,8836527,8836263,8835639,8836227],"length":1,"stats":{"Line":5}},{"line":93,"address":[8835632,8836062,8836068,8836096,8836114],"length":1,"stats":{"Line":3}},{"line":96,"address":[8836220,8836330,8835772,8835864],"length":1,"stats":{"Line":4}},{"line":97,"address":[8837281,8837261,8837136,8836563,8837227,8836560,8837161,8837390,8838468],"length":1,"stats":{"Line":5}},{"line":98,"address":[8837254,8837200,8837421,8837335],"length":1,"stats":{"Line":3}},{"line":99,"address":[8837677],"length":1,"stats":{"Line":1}},{"line":100,"address":[8837967],"length":1,"stats":{"Line":1}},{"line":101,"address":[8837713],"length":1,"stats":{"Line":1}},{"line":106,"address":[8838043],"length":1,"stats":{"Line":1}},{"line":107,"address":[8809485],"length":1,"stats":{"Line":3}},{"line":108,"address":[8838689,8838744,8838804],"length":1,"stats":{"Line":2}},{"line":109,"address":[8809538,8809573],"length":1,"stats":{"Line":3}},{"line":110,"address":[8836576,8837129,8836617,8836592,8836821,8836579,8836687,8836723],"length":1,"stats":{"Line":4}},{"line":111,"address":[8836711,8836660,8836778,8836852],"length":1,"stats":{"Line":3}},{"line":112,"address":[8836586,8837103],"length":1,"stats":{"Line":2}},{"line":114,"address":[8836350,8835791,8836251,8835883,8836393,8836318],"length":1,"stats":{"Line":5}},{"line":115,"address":[8835704,8836133,8836041],"length":1,"stats":{"Line":2}},{"line":122,"address":[8839005,8839743,8839443,8839479,8839769,8839578,8839360,8838903,8839385],"length":1,"stats":{"Line":5}},{"line":124,"address":[8839776,8838896,8839332,8839326,8839794],"length":1,"stats":{"Line":3}},{"line":127,"address":[8839546,8839128,8839436,8839036],"length":1,"stats":{"Line":4}},{"line":128,"address":[8840446,8841894,8840400,8840623,8839827,8839824,8840530,8840594,8840573,8840742],"length":1,"stats":{"Line":6}},{"line":129,"address":[8840678,8840492,8840560,8840776],"length":1,"stats":{"Line":3}},{"line":130,"address":[8841060],"length":1,"stats":{"Line":1}},{"line":131,"address":[8841361],"length":1,"stats":{"Line":1}},{"line":132,"address":[8841102],"length":1,"stats":{"Line":1}},{"line":137,"address":[8841842,8842048],"length":1,"stats":{"Line":2}},{"line":138,"address":[8841756],"length":1,"stats":{"Line":1}},{"line":139,"address":[8841543,8841456,8841741],"length":1,"stats":{"Line":3}},{"line":140,"address":[8841425,8841528],"length":1,"stats":{"Line":2}},{"line":143,"address":[8809857,8809930],"length":1,"stats":{"Line":3}},{"line":144,"address":[8842193],"length":1,"stats":{"Line":1}},{"line":146,"address":[8842204],"length":1,"stats":{"Line":1}},{"line":147,"address":[8809876],"length":1,"stats":{"Line":4}},{"line":148,"address":[8843795,8843844],"length":1,"stats":{"Line":2}},{"line":149,"address":[8843918],"length":1,"stats":{"Line":1}},{"line":150,"address":[8842657,8843817,8843930],"length":1,"stats":{"Line":2}},{"line":151,"address":[8842673],"length":1,"stats":{"Line":1}},{"line":152,"address":[8842741],"length":1,"stats":{"Line":1}},{"line":153,"address":[8843142,8843046],"length":1,"stats":{"Line":2}},{"line":154,"address":[8843382,8843182],"length":1,"stats":{"Line":2}},{"line":155,"address":[8843471],"length":1,"stats":{"Line":1}},{"line":156,"address":[8843568],"length":1,"stats":{"Line":1}},{"line":157,"address":[8810081,8810044],"length":1,"stats":{"Line":2}},{"line":158,"address":[8840393,8839881,8839840,8839856,8840085,8839987,8839843,8839951],"length":1,"stats":{"Line":4}},{"line":159,"address":[8839975,8840042,8839924,8840116],"length":1,"stats":{"Line":3}},{"line":160,"address":[8840367,8839850],"length":1,"stats":{"Line":2}},{"line":162,"address":[8839467,8839055,8839566,8839609,8839534,8839147],"length":1,"stats":{"Line":5}},{"line":163,"address":[8839305,8839813,8838968],"length":1,"stats":{"Line":2}}],"covered":76,"coverable":88},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","tests","integration_tests.rs"],"content":"extern crate influxdb;\n\n#[path = \"./utilities.rs\"]\nmod utilities;\n\nuse serde_derive::Deserialize;\nuse utilities::{\n    assert_result_err, assert_result_ok, create_client, create_db, delete_db, run_test,\n};\n\nuse influxdb::{Client, Error, InfluxDbWriteable, ReadQuery, Timestamp};\n\n/// INTEGRATION TEST\n///\n/// This test case tests whether the InfluxDB server can be connected to and gathers info about it - tested with tokio 1.0\n#[tokio::test]\n#[cfg(not(any(tarpaulin_include)))]\nasync fn test_ping_influx_db_tokio() {\n    let client = create_client(\"notusedhere\");\n    let result = client.ping().await;\n    assert_result_ok(&result);\n\n    let (build, version) = result.unwrap();\n    assert!(!build.is_empty(), \"Build should not be empty\");\n    assert!(!version.is_empty(), \"Build should not be empty\");\n\n    println!(\"build: {build} version: {version}\");\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests connection error\n#[tokio::test]\n#[cfg(not(tarpaulin_include))]\nasync fn test_connection_error() {\n    let test_name = \"test_connection_error\";\n    let client =\n        Client::new(\"http://127.0.0.1:10086\", test_name).with_auth(\"nopriv_user\", \"password\");\n    let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n    let read_result = client.query(read_query).await;\n    assert_result_err(&read_result);\n    match read_result {\n        Err(Error::ConnectionError { .. }) => {}\n        _ => panic!(\n            \"Should cause a ConnectionError: {}\",\n            read_result.unwrap_err()\n        ),\n    }\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests the Authentication\n#[tokio::test]\n#[cfg(not(tarpaulin_include))]\nasync fn test_authed_write_and_read() {\n    const TEST_NAME: &str = \"test_authed_write_and_read\";\n\n    run_test(\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"CREATE DATABASE {TEST_NAME}\");\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not setup db\");\n\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_field(\"temperature\", 82);\n            let write_result = client.query(write_query).await;\n            assert_result_ok(&write_result);\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = client.query(read_query).await;\n            assert_result_ok(&read_result);\n            assert!(\n                !read_result.unwrap().contains(\"error\"),\n                \"Data contained a database error\"\n            );\n        },\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"DROP DATABASE {TEST_NAME}\");\n\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests the Authentication\n#[tokio::test]\n#[cfg(not(tarpaulin_include))]\nasync fn test_wrong_authed_write_and_read() {\n    use http::StatusCode;\n\n    const TEST_NAME: &str = \"test_wrong_authed_write_and_read\";\n\n    run_test(\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"CREATE DATABASE {TEST_NAME}\");\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not setup db\");\n\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"wrong_user\", \"password\");\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_field(\"temperature\", 82);\n            let write_result = client.query(write_query).await;\n            assert_result_err(&write_result);\n            match write_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    write_result.unwrap_err()\n                ),\n            }\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = client.query(read_query).await;\n            assert_result_err(&read_result);\n            match read_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    read_result.unwrap_err()\n                ),\n            }\n\n            let client = Client::new(\"http://127.0.0.1:9086\", TEST_NAME)\n                .with_auth(\"nopriv_user\", \"password\");\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = client.query(read_query).await;\n            assert_result_err(&read_result);\n            match read_result {\n                Err(Error::ApiError(code)) if code == StatusCode::FORBIDDEN.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHENTICATED): {}\",\n                    read_result.unwrap_err()\n                ),\n            }\n        },\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"DROP DATABASE {TEST_NAME}\");\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests the Authentication\n#[tokio::test]\n#[cfg(not(tarpaulin_include))]\nasync fn test_non_authed_write_and_read() {\n    use http::StatusCode;\n\n    const TEST_NAME: &str = \"test_non_authed_write_and_read\";\n\n    run_test(\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"CREATE DATABASE {TEST_NAME}\");\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not setup db\");\n            let non_authed_client = Client::new(\"http://127.0.0.1:9086\", TEST_NAME);\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_field(\"temperature\", 82);\n            let write_result = non_authed_client.query(write_query).await;\n            assert_result_err(&write_result);\n            match write_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    write_result.unwrap_err()\n                ),\n            }\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = non_authed_client.query(read_query).await;\n\n            assert_result_err(&read_result);\n            match read_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    read_result.unwrap_err()\n                ),\n            }\n        },\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"DROP DATABASE {TEST_NAME}\");\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This integration tests that writing data and retrieving the data again is working\n#[tokio::test]\n#[cfg(not(tarpaulin_include))]\nasync fn test_write_and_read_field() {\n    const TEST_NAME: &str = \"test_write_field\";\n\n    run_test(\n        || async move {\n            create_db(TEST_NAME).await.expect(\"could not setup db\");\n            let client = create_client(TEST_NAME);\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_field(\"temperature\", 82);\n            let write_result = client.query(write_query).await;\n            assert_result_ok(&write_result);\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = client.query(read_query).await;\n            assert_result_ok(&read_result);\n            assert!(\n                !read_result.unwrap().contains(\"error\"),\n                \"Data contained a database error\"\n            );\n        },\n        || async move {\n            delete_db(TEST_NAME).await.expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests the authentication on json reads\n#[tokio::test]\n#[cfg(feature = \"serde\")]\n#[cfg(not(tarpaulin_include))]\nasync fn test_json_non_authed_read() {\n    use http::StatusCode;\n\n    const TEST_NAME: &str = \"test_json_non_authed_read\";\n\n    run_test(\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"CREATE DATABASE {TEST_NAME}\");\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not setup db\");\n            let non_authed_client = Client::new(\"http://127.0.0.1:9086\", TEST_NAME);\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = non_authed_client.json_query(read_query).await;\n            assert_result_err(&read_result);\n            match read_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    read_result.unwrap_err()\n                ),\n            }\n        },\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"DROP DATABASE {TEST_NAME}\");\n\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not clean up db\");\n        },\n    )\n    .await\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests the authentication on json reads\n#[tokio::test]\n#[cfg(feature = \"serde\")]\n#[cfg(not(tarpaulin_include))]\nasync fn test_json_authed_read() {\n    const TEST_NAME: &str = \"test_json_authed_read\";\n\n    run_test(\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"CREATE DATABASE {TEST_NAME}\");\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not setup db\");\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = client.json_query(read_query).await;\n            assert_result_ok(&read_result);\n        },\n        || async move {\n            let client =\n                Client::new(\"http://127.0.0.1:9086\", TEST_NAME).with_auth(\"admin\", \"password\");\n            let query = format!(\"DROP DATABASE {TEST_NAME}\");\n\n            client\n                .query(ReadQuery::new(query))\n                .await\n                .expect(\"could not clean up db\");\n        },\n    )\n    .await\n}\n\n/// INTEGRATION TEST\n///\n/// This integration tests that writing data and retrieving the data again is working\n#[tokio::test]\n#[cfg(feature = \"serde\")]\n#[cfg(not(tarpaulin_include))]\nasync fn test_write_and_read_option() {\n    const TEST_NAME: &str = \"test_write_and_read_option\";\n\n    run_test(\n        || {\n            async move {\n                create_db(TEST_NAME).await.expect(\"could not setup db\");\n\n                let client = create_client(TEST_NAME);\n                // Todo: Convert this to derive based insert for easier comparison of structs\n                let write_query = Timestamp::Hours(11)\n                    .try_into_query(\"weather\")\n                    .unwrap()\n                    .add_field(\"temperature\", 82)\n                    .add_field(\"wind_strength\", <Option<u64>>::None);\n                let write_result = client.query(write_query).await;\n                assert_result_ok(&write_result);\n\n                #[derive(Deserialize, Debug, PartialEq)]\n                struct Weather {\n                    time: String,\n                    // different order to verify field names\n                    // are being used instead of just order\n                    wind_strength: Option<u64>,\n                    temperature: i32,\n                }\n\n                let query = ReadQuery::new(\"SELECT time, temperature, wind_strength FROM weather\");\n                let result = client\n                    .json_query(query)\n                    .await\n                    .and_then(|mut db_result| db_result.deserialize_next::<Weather>());\n                assert_result_ok(&result);\n\n                assert_eq!(\n                    result.unwrap().series[0].values[0],\n                    Weather {\n                        time: \"1970-01-01T11:00:00Z\".to_string(),\n                        temperature: 82,\n                        wind_strength: None,\n                    }\n                );\n            }\n        },\n        || async move {\n            delete_db(\"test_write_and_read_option\")\n                .await\n                .expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests whether JSON can be decoded from a InfluxDB response and whether that JSON\n/// is equal to the data which was written to the database\n#[tokio::test]\n#[cfg(feature = \"serde\")]\n#[cfg(not(tarpaulin_include))]\nasync fn test_json_query() {\n    const TEST_NAME: &str = \"test_json_query\";\n\n    run_test(\n        || async move {\n            create_db(TEST_NAME).await.expect(\"could not setup db\");\n\n            let client = create_client(TEST_NAME);\n\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_field(\"temperature\", 82);\n            let write_result = client.query(write_query).await;\n            assert_result_ok(&write_result);\n\n            #[derive(Deserialize, Debug, PartialEq)]\n            struct Weather {\n                time: String,\n                temperature: i32,\n            }\n\n            let query = ReadQuery::new(\"SELECT * FROM weather\");\n            let result = client\n                .json_query(query)\n                .await\n                .and_then(|mut db_result| db_result.deserialize_next::<Weather>());\n            assert_result_ok(&result);\n\n            assert_eq!(\n                result.unwrap().series[0].values[0],\n                Weather {\n                    time: \"1970-01-01T11:00:00Z\".to_string(),\n                    temperature: 82\n                }\n            );\n        },\n        || async move {\n            delete_db(TEST_NAME).await.expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests whether the response to a GROUP BY can be parsed by\n/// deserialize_next_tagged into a tags struct\n#[tokio::test]\n#[cfg(feature = \"serde\")]\n#[cfg(not(tarpaulin_include))]\nasync fn test_json_query_tagged() {\n    const TEST_NAME: &str = \"test_json_query_tagged\";\n\n    run_test(\n        || async move {\n            create_db(TEST_NAME).await.expect(\"could not setup db\");\n\n            let client = create_client(TEST_NAME);\n\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_tag(\"location\", \"London\")\n                .add_field(\"temperature\", 82);\n            let write_result = client.query(write_query).await;\n            assert_result_ok(&write_result);\n\n            #[derive(Deserialize, Debug, PartialEq)]\n            struct WeatherMeta {\n                location: String,\n            }\n\n            #[derive(Deserialize, Debug, PartialEq)]\n            struct Weather {\n                time: String,\n                temperature: i32,\n            }\n\n            let query = ReadQuery::new(\"SELECT * FROM weather GROUP BY location\");\n            let result = client.json_query(query).await.and_then(|mut db_result| {\n                db_result.deserialize_next_tagged::<WeatherMeta, Weather>()\n            });\n            assert_result_ok(&result);\n            let result = result.unwrap();\n\n            assert_eq!(\n                result.series[0].tags,\n                WeatherMeta {\n                    location: \"London\".to_string(),\n                }\n            );\n            assert_eq!(\n                result.series[0].values[0],\n                Weather {\n                    time: \"1970-01-01T11:00:00Z\".to_string(),\n                    temperature: 82\n                }\n            );\n        },\n        || async move {\n            delete_db(TEST_NAME).await.expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests whether JSON can be decoded from a InfluxDB response and whether that JSON\n/// is equal to the data which was written to the database\n/// (tested with tokio)\n#[tokio::test]\n#[cfg(all(feature = \"serde\", not(any(tarpaulin_include))))]\nasync fn test_json_query_vec() {\n    const TEST_NAME: &str = \"test_json_query_vec\";\n\n    run_test(\n        || async move {\n            create_db(TEST_NAME).await.expect(\"could not setup db\");\n\n            let client = create_client(TEST_NAME);\n            let write_query1 = Timestamp::Hours(11)\n                .try_into_query(\"temperature_vec\")\n                .unwrap()\n                .add_field(\"temperature\", 16);\n            let write_query2 = Timestamp::Hours(12)\n                .try_into_query(\"temperature_vec\")\n                .unwrap()\n                .add_field(\"temperature\", 17);\n            let write_query3 = Timestamp::Hours(13)\n                .try_into_query(\"temperature_vec\")\n                .unwrap()\n                .add_field(\"temperature\", 18);\n\n            let _write_result = client.query(write_query1).await;\n            let _write_result2 = client.query(write_query2).await;\n            let _write_result2 = client.query(write_query3).await;\n\n            #[derive(Deserialize, Debug, PartialEq)]\n            struct Weather {\n                time: String,\n                temperature: i32,\n            }\n\n            let query = ReadQuery::new(\"SELECT * FROM temperature_vec\");\n            let result = client\n                .json_query(query)\n                .await\n                .and_then(|mut db_result| db_result.deserialize_next::<Weather>());\n            assert_result_ok(&result);\n            assert_eq!(result.unwrap().series[0].values.len(), 3);\n        },\n        || async move {\n            delete_db(TEST_NAME).await.expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This integration test tests whether using the wrong query method fails building the query\n#[tokio::test]\n#[cfg(feature = \"serde\")]\n#[cfg(not(tarpaulin_include))]\nasync fn test_serde_multi_query() {\n    const TEST_NAME: &str = \"test_serde_multi_query\";\n\n    run_test(\n        || async move {\n            create_db(TEST_NAME).await.expect(\"could not setup db\");\n\n            #[derive(Deserialize, Debug, PartialEq)]\n            struct Temperature {\n                time: String,\n                temperature: i32,\n            }\n\n            #[derive(Deserialize, Debug, PartialEq)]\n            struct Humidity {\n                time: String,\n                humidity: i32,\n            }\n\n            let client = create_client(TEST_NAME);\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"temperature\")\n                .unwrap()\n                .add_field(\"temperature\", 16);\n            let write_query2 = Timestamp::Hours(11)\n                .try_into_query(\"humidity\")\n                .unwrap()\n                .add_field(\"humidity\", 69);\n\n            let write_result = client.query(write_query).await;\n            let write_result2 = client.query(write_query2).await;\n            assert_result_ok(&write_result);\n            assert_result_ok(&write_result2);\n\n            let result = client\n                .json_query(\n                    ReadQuery::new(\"SELECT * FROM temperature\").add_query(\"SELECT * FROM humidity\"),\n                )\n                .await\n                .and_then(|mut db_result| {\n                    let temp = db_result.deserialize_next::<Temperature>()?;\n                    let humidity = db_result.deserialize_next::<Humidity>()?;\n\n                    Ok((temp, humidity))\n                });\n            assert_result_ok(&result);\n\n            let (temp, humidity) = result.unwrap();\n            assert_eq!(\n                temp.series[0].values[0],\n                Temperature {\n                    time: \"1970-01-01T11:00:00Z\".to_string(),\n                    temperature: 16\n                },\n            );\n            assert_eq!(\n                humidity.series[0].values[0],\n                Humidity {\n                    time: \"1970-01-01T11:00:00Z\".to_string(),\n                    humidity: 69\n                }\n            );\n        },\n        || async move {\n            delete_db(TEST_NAME).await.expect(\"could not clean up db\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This integration test tests whether using the wrong query method fails building the query\n#[tokio::test]\n#[cfg(feature = \"serde\")]\n#[cfg(not(tarpaulin_include))]\nasync fn test_wrong_query_errors() {\n    let client = create_client(\"test_name\");\n    let result = client\n        .json_query(ReadQuery::new(\"CREATE DATABASE this_should_fail\"))\n        .await;\n    assert!(\n        result.is_err(),\n        \"Should only build SELECT and SHOW queries.\"\n    );\n}\n","traces":[{"line":1,"address":[8833376],"length":1,"stats":{"Line":1}},{"line":16,"address":[8808247,8808849,8809071,8809981,8808408,8808777,8808752,8808891,8810062],"length":1,"stats":{"Line":5}},{"line":18,"address":[8808733,8808240,8810114,8808727,8810096],"length":1,"stats":{"Line":3}},{"line":19,"address":[8808822],"length":1,"stats":{"Line":1}},{"line":20,"address":[8872500],"length":1,"stats":{"Line":3}},{"line":21,"address":[8809351],"length":1,"stats":{"Line":1}},{"line":23,"address":[8809399],"length":1,"stats":{"Line":1}},{"line":24,"address":[8809551,8810044,8809635,8809610],"length":1,"stats":{"Line":2}},{"line":25,"address":[8810014,8809671,8809624,8809728],"length":1,"stats":{"Line":2}},{"line":27,"address":[8808439,8809685,8809760],"length":1,"stats":{"Line":3}},{"line":28,"address":[8810073,8808706,8809870,8808959,8809358,8810133,8808371,8809562],"length":1,"stats":{"Line":3}},{"line":33,"address":[8789499,8788612,8788742,8788700,8789048,8788560,8789680,8788221,8788119],"length":1,"stats":{"Line":5}},{"line":35,"address":[8789712,8788540,8789730,8788112,8788546],"length":1,"stats":{"Line":3}},{"line":36,"address":[8788585,8788655],"length":1,"stats":{"Line":2}},{"line":38,"address":[8788789,8788663],"length":1,"stats":{"Line":2}},{"line":39,"address":[8788826],"length":1,"stats":{"Line":1}},{"line":40,"address":[8788727,8788896,8789079,8788993],"length":1,"stats":{"Line":3}},{"line":41,"address":[8789295],"length":1,"stats":{"Line":1}},{"line":42,"address":[8789343,8788342,8788252],"length":1,"stats":{"Line":3}},{"line":44,"address":[8789533],"length":1,"stats":{"Line":0}},{"line":46,"address":[8789385],"length":1,"stats":{"Line":0}},{"line":48,"address":[8788294,8788437],"length":1,"stats":{"Line":0}},{"line":49,"address":[8871750,8871786],"length":1,"stats":{"Line":3}},{"line":54,"address":[8814249,8814224,8813719,8814442,8813821,8814307,8814607,8814633,8814343],"length":1,"stats":{"Line":5}},{"line":56,"address":[8814176,8814194,8814142,8814148,8813712],"length":1,"stats":{"Line":3}},{"line":59,"address":[8814300,8813852,8813944,8814410],"length":1,"stats":{"Line":4}},{"line":60,"address":[8815787,8815584,8815715,8815624,8816987,8814643,8815767,8816213,8815752,8814640],"length":1,"stats":{"Line":6}},{"line":61,"address":[8815667],"length":1,"stats":{"Line":1}},{"line":62,"address":[8815834,8815675],"length":1,"stats":{"Line":2}},{"line":63,"address":[8815874,8815949],"length":1,"stats":{"Line":2}},{"line":64,"address":[8816372,8816418,8816164],"length":1,"stats":{"Line":3}},{"line":65,"address":[8816053],"length":1,"stats":{"Line":1}},{"line":66,"address":[8816194,8815742,8816152,8816244,8816404],"length":1,"stats":{"Line":4}},{"line":67,"address":[8816450],"length":1,"stats":{"Line":1}},{"line":70,"address":[8816511],"length":1,"stats":{"Line":1}},{"line":72,"address":[8816600],"length":1,"stats":{"Line":1}},{"line":73,"address":[8816695],"length":1,"stats":{"Line":1}},{"line":74,"address":[8816725],"length":1,"stats":{"Line":1}},{"line":75,"address":[8815757,8816998,8816771],"length":1,"stats":{"Line":2}},{"line":76,"address":[8817201],"length":1,"stats":{"Line":1}},{"line":78,"address":[8817253],"length":1,"stats":{"Line":1}},{"line":79,"address":[8817285,8815772,8817461,8817395],"length":1,"stats":{"Line":3}},{"line":80,"address":[8817683],"length":1,"stats":{"Line":1}},{"line":81,"address":[8817917,8818046,8817826],"length":1,"stats":{"Line":1}},{"line":82,"address":[8817731,8817880],"length":1,"stats":{"Line":2}},{"line":85,"address":[8817344,8818113,8816655,8817217,8814650,8817690,8815913,8817960],"length":1,"stats":{"Line":2}},{"line":86,"address":[8815230,8815569,8814656,8814672,8814697,8814819,8814777,8814659],"length":1,"stats":{"Line":4}},{"line":88,"address":[8814740,8814866],"length":1,"stats":{"Line":2}},{"line":89,"address":[8814978,8814903],"length":1,"stats":{"Line":2}},{"line":91,"address":[8815187,8815386,8815429],"length":1,"stats":{"Line":3}},{"line":92,"address":[8815079],"length":1,"stats":{"Line":1}},{"line":93,"address":[8815261,8815214,8815418,8815175,8814804],"length":1,"stats":{"Line":4}},{"line":94,"address":[8815461],"length":1,"stats":{"Line":1}},{"line":95,"address":[8815527,8814666,8814942],"length":1,"stats":{"Line":2}},{"line":97,"address":[8814331,8814398,8813871,8813963,8814430,8814473],"length":1,"stats":{"Line":5}},{"line":98,"address":[8814213,8813784,8814121],"length":1,"stats":{"Line":2}},{"line":103,"address":[8827079,8827802,8827967,8827609,8827993,8827703,8827584,8827667,8827181],"length":1,"stats":{"Line":5}},{"line":105,"address":[8827072,8827536,8827554,8827508,8827502],"length":1,"stats":{"Line":3}},{"line":110,"address":[8827212,8827304,8827660,8827770],"length":1,"stats":{"Line":4}},{"line":111,"address":[8828019,8829716,8829191,8829005,8828016,8829170,8828944,8829127,8829212,8829241,8830565],"length":1,"stats":{"Line":7}},{"line":112,"address":[8829062],"length":1,"stats":{"Line":1}},{"line":113,"address":[8829291,8829084],"length":1,"stats":{"Line":2}},{"line":114,"address":[8829335,8829417],"length":1,"stats":{"Line":2}},{"line":115,"address":[8829893,8829541,8829664,8829939],"length":1,"stats":{"Line":4}},{"line":116,"address":[8829550],"length":1,"stats":{"Line":1}},{"line":117,"address":[8829649,8829750,8829697,8829925,8829157],"length":1,"stats":{"Line":4}},{"line":118,"address":[8829971],"length":1,"stats":{"Line":1}},{"line":121,"address":[8830032],"length":1,"stats":{"Line":1}},{"line":123,"address":[8830124],"length":1,"stats":{"Line":1}},{"line":124,"address":[8830222],"length":1,"stats":{"Line":1}},{"line":125,"address":[8830252],"length":1,"stats":{"Line":1}},{"line":126,"address":[8830498,8830301,8830579,8829178],"length":1,"stats":{"Line":3}},{"line":127,"address":[8830806],"length":1,"stats":{"Line":1}},{"line":128,"address":[8830869],"length":1,"stats":{"Line":1}},{"line":129,"address":[8830988],"length":1,"stats":{"Line":1}},{"line":130,"address":[8831300],"length":1,"stats":{"Line":0}},{"line":132,"address":[8830917],"length":1,"stats":{"Line":0}},{"line":136,"address":[8831070],"length":1,"stats":{"Line":1}},{"line":137,"address":[8861165],"length":1,"stats":{"Line":3}},{"line":138,"address":[8831685],"length":1,"stats":{"Line":1}},{"line":139,"address":[8831752],"length":1,"stats":{"Line":1}},{"line":140,"address":[8831874],"length":1,"stats":{"Line":1}},{"line":141,"address":[8832328],"length":1,"stats":{"Line":0}},{"line":143,"address":[8831802],"length":1,"stats":{"Line":0}},{"line":147,"address":[8831956],"length":1,"stats":{"Line":1}},{"line":148,"address":[8832011],"length":1,"stats":{"Line":1}},{"line":149,"address":[8832051],"length":1,"stats":{"Line":1}},{"line":150,"address":[8829220,8832137,8832250,8832486],"length":1,"stats":{"Line":3}},{"line":151,"address":[8832723],"length":1,"stats":{"Line":1}},{"line":152,"address":[8832771],"length":1,"stats":{"Line":1}},{"line":153,"address":[8832886],"length":1,"stats":{"Line":1}},{"line":154,"address":[8833160],"length":1,"stats":{"Line":0}},{"line":156,"address":[8832813],"length":1,"stats":{"Line":0}},{"line":159,"address":[8832977,8830448,8831704,8828026,8830821,8832086,8832199,8833318,8829377,8831172,8832730,8830182],"length":1,"stats":{"Line":2}},{"line":160,"address":[8828179,8828590,8828032,8828057,8828929,8828137,8828000,8828003],"length":1,"stats":{"Line":4}},{"line":162,"address":[8828226,8828100],"length":1,"stats":{"Line":2}},{"line":163,"address":[8828338,8828263],"length":1,"stats":{"Line":2}},{"line":164,"address":[8828547,8828789,8828746],"length":1,"stats":{"Line":3}},{"line":165,"address":[8828439],"length":1,"stats":{"Line":1}},{"line":166,"address":[8828164,8828535,8828574,8828621,8828778],"length":1,"stats":{"Line":4}},{"line":167,"address":[8828821],"length":1,"stats":{"Line":1}},{"line":168,"address":[8828302,8828010,8828887],"length":1,"stats":{"Line":2}},{"line":170,"address":[8827758,8827691,8827231,8827323,8827790,8827833],"length":1,"stats":{"Line":5}},{"line":171,"address":[8827144,8827481,8827573],"length":1,"stats":{"Line":2}},{"line":176,"address":[8822103,8822778,8822969,8822679,8822643,8822560,8822943,8822205,8822585],"length":1,"stats":{"Line":5}},{"line":178,"address":[8822526,8822532,8822096,8822976,8822994],"length":1,"stats":{"Line":3}},{"line":183,"address":[8822746,8822636,8822236,8822328],"length":1,"stats":{"Line":4}},{"line":184,"address":[8824160,8824011,8823968,8824181,8824655,8823040,8824117,8823043,8825429,8824207],"length":1,"stats":{"Line":6}},{"line":185,"address":[8824059],"length":1,"stats":{"Line":1}},{"line":186,"address":[8824074,8824254],"length":1,"stats":{"Line":2}},{"line":187,"address":[8824298,8824377],"length":1,"stats":{"Line":2}},{"line":188,"address":[8824606,8824486,8824823,8824869],"length":1,"stats":{"Line":4}},{"line":189,"address":[8824495],"length":1,"stats":{"Line":1}},{"line":190,"address":[8824147,8824855,8824594,8824686,8824636],"length":1,"stats":{"Line":4}},{"line":191,"address":[8824901],"length":1,"stats":{"Line":1}},{"line":192,"address":[8824967],"length":1,"stats":{"Line":1}},{"line":194,"address":[8825003],"length":1,"stats":{"Line":1}},{"line":195,"address":[8825098],"length":1,"stats":{"Line":1}},{"line":196,"address":[8825128],"length":1,"stats":{"Line":1}},{"line":197,"address":[8825368,8825440,8824168,8825174],"length":1,"stats":{"Line":3}},{"line":198,"address":[8825658],"length":1,"stats":{"Line":1}},{"line":199,"address":[8825715],"length":1,"stats":{"Line":1}},{"line":200,"address":[8825825],"length":1,"stats":{"Line":1}},{"line":201,"address":[8826118],"length":1,"stats":{"Line":0}},{"line":203,"address":[8825757],"length":1,"stats":{"Line":0}},{"line":207,"address":[8825904],"length":1,"stats":{"Line":1}},{"line":208,"address":[8826272,8826046,8825936,8824189],"length":1,"stats":{"Line":3}},{"line":210,"address":[8826503],"length":1,"stats":{"Line":1}},{"line":211,"address":[8826551],"length":1,"stats":{"Line":1}},{"line":212,"address":[8826666],"length":1,"stats":{"Line":1}},{"line":213,"address":[8826876],"length":1,"stats":{"Line":0}},{"line":215,"address":[8826593],"length":1,"stats":{"Line":0}},{"line":218,"address":[8823050,8826510,8826757,8825058,8824337,8825318,8825670,8825995,8827034],"length":1,"stats":{"Line":2}},{"line":219,"address":[8823203,8823953,8823024,8823027,8823056,8823161,8823081,8823614],"length":1,"stats":{"Line":4}},{"line":221,"address":[8823124,8823250],"length":1,"stats":{"Line":2}},{"line":222,"address":[8823287,8823362],"length":1,"stats":{"Line":2}},{"line":223,"address":[8823770,8823813,8823571],"length":1,"stats":{"Line":3}},{"line":224,"address":[8823463],"length":1,"stats":{"Line":1}},{"line":225,"address":[8823645,8823188,8823802,8823559,8823598],"length":1,"stats":{"Line":4}},{"line":226,"address":[8823845],"length":1,"stats":{"Line":1}},{"line":227,"address":[8823326,8823034,8823911],"length":1,"stats":{"Line":2}},{"line":229,"address":[8822255,8822734,8822766,8822667,8822347,8822809],"length":1,"stats":{"Line":5}},{"line":230,"address":[8822505,8822168,8823013],"length":1,"stats":{"Line":2}},{"line":235,"address":[8810253,8810633,8810691,8810151,8810608,8810826,8811017,8810991,8810727],"length":1,"stats":{"Line":5}},{"line":237,"address":[8811042,8811024,8810580,8810144,8810574],"length":1,"stats":{"Line":3}},{"line":240,"address":[8810794,8810284,8810684,8810376],"length":1,"stats":{"Line":4}},{"line":241,"address":[8811104,8811268,8811219,8812078,8811091,8811398,8811144,8811288,8811088,8811253],"length":1,"stats":{"Line":6}},{"line":242,"address":[8811184,8811246,8811343,8811429],"length":1,"stats":{"Line":3}},{"line":243,"address":[8811686],"length":1,"stats":{"Line":1}},{"line":245,"address":[8811705],"length":1,"stats":{"Line":1}},{"line":246,"address":[8811796],"length":1,"stats":{"Line":1}},{"line":247,"address":[8811826],"length":1,"stats":{"Line":1}},{"line":248,"address":[8811258,8812089,8811872],"length":1,"stats":{"Line":2}},{"line":249,"address":[8812283],"length":1,"stats":{"Line":1}},{"line":251,"address":[8812335],"length":1,"stats":{"Line":1}},{"line":252,"address":[8812367,8811273,8812533,8812473],"length":1,"stats":{"Line":3}},{"line":253,"address":[8812743],"length":1,"stats":{"Line":1}},{"line":254,"address":[8812977,8813083,8812886],"length":1,"stats":{"Line":1}},{"line":255,"address":[8812791,8812940],"length":1,"stats":{"Line":2}},{"line":258,"address":[8811760,8812750,8813150,8812422,8813020,8811095,8812299],"length":1,"stats":{"Line":2}},{"line":259,"address":[8811075,8813263,8813299,8813168,8813193,8813705,8813397,8811072],"length":1,"stats":{"Line":4}},{"line":260,"address":[8813428,8813354,8813236,8813287],"length":1,"stats":{"Line":3}},{"line":261,"address":[8813679,8811082],"length":1,"stats":{"Line":2}},{"line":263,"address":[8810395,8810303,8810814,8810857,8810782,8810715],"length":1,"stats":{"Line":5}},{"line":264,"address":[8811061,8810216,8810553],"length":1,"stats":{"Line":2}},{"line":269,"address":[8805311,8804589,8804487,8805337,8804928,8805146,8804953,8805011,8805047],"length":1,"stats":{"Line":5}},{"line":272,"address":[8804480,8804914,8805344,8805362,8804908],"length":1,"stats":{"Line":3}},{"line":277,"address":[8804620,8805004,8805114,8804710],"length":1,"stats":{"Line":4}},{"line":278,"address":[8806483,8806361,8805411,8805408,8806917,8806446,8806503,8807502,8806336],"length":1,"stats":{"Line":5}},{"line":279,"address":[8806401],"length":1,"stats":{"Line":1}},{"line":280,"address":[8806547,8806409],"length":1,"stats":{"Line":2}},{"line":281,"address":[8806584,8806659],"length":1,"stats":{"Line":2}},{"line":282,"address":[8806874,8807070,8807113],"length":1,"stats":{"Line":3}},{"line":283,"address":[8806763],"length":1,"stats":{"Line":1}},{"line":284,"address":[8806473,8806901,8807102,8806862,8806948],"length":1,"stats":{"Line":4}},{"line":285,"address":[8807145],"length":1,"stats":{"Line":1}},{"line":286,"address":[8807211],"length":1,"stats":{"Line":1}},{"line":288,"address":[8807250],"length":1,"stats":{"Line":1}},{"line":289,"address":[8806488,8807330,8807513,8807447],"length":1,"stats":{"Line":3}},{"line":290,"address":[8807727],"length":1,"stats":{"Line":1}},{"line":291,"address":[8807775],"length":1,"stats":{"Line":1}},{"line":292,"address":[8807890],"length":1,"stats":{"Line":1}},{"line":293,"address":[8808071],"length":1,"stats":{"Line":0}},{"line":295,"address":[8807817],"length":1,"stats":{"Line":0}},{"line":298,"address":[8807734,8807981,8808228,8805415,8806623,8807396,8807282],"length":1,"stats":{"Line":2}},{"line":299,"address":[8805392,8805571,8805395,8805982,8805424,8805529,8805449,8806321],"length":1,"stats":{"Line":4}},{"line":301,"address":[8805492,8805618],"length":1,"stats":{"Line":2}},{"line":302,"address":[8805655,8805730],"length":1,"stats":{"Line":2}},{"line":304,"address":[8805939,8806138,8806181],"length":1,"stats":{"Line":3}},{"line":305,"address":[8805831],"length":1,"stats":{"Line":1}},{"line":306,"address":[8805556,8805966,8805927,8806170,8806013],"length":1,"stats":{"Line":4}},{"line":307,"address":[8806213],"length":1,"stats":{"Line":1}},{"line":308,"address":[8806279,8805402,8805694],"length":1,"stats":{"Line":2}},{"line":310,"address":[8804639,8805177,8804729,8805102,8805035,8805134],"length":1,"stats":{"Line":5}},{"line":311,"address":[8804552,8805381,8804887],"length":1,"stats":{"Line":2}},{"line":316,"address":[8789767,8789869,8790339,8790256,8790639,8790281,8790375,8790665,8790474],"length":1,"stats":{"Line":5}},{"line":319,"address":[8790194,8790208,8790226,8789760,8790188],"length":1,"stats":{"Line":3}},{"line":322,"address":[8790442,8790332,8789990,8789900],"length":1,"stats":{"Line":4}},{"line":323,"address":[8790861,8790841,8790675,8790672,8791269,8790704,8790729,8791719,8790804],"length":1,"stats":{"Line":5}},{"line":325,"address":[8790769,8790905],"length":1,"stats":{"Line":2}},{"line":326,"address":[8791017,8790942],"length":1,"stats":{"Line":2}},{"line":327,"address":[8791465,8791226,8791422],"length":1,"stats":{"Line":3}},{"line":328,"address":[8791118],"length":1,"stats":{"Line":1}},{"line":329,"address":[8791300,8791253,8791214,8791454,8790831],"length":1,"stats":{"Line":4}},{"line":330,"address":[8791497],"length":1,"stats":{"Line":1}},{"line":332,"address":[8791558],"length":1,"stats":{"Line":1}},{"line":333,"address":[8791730,8790846,8791590],"length":1,"stats":{"Line":2}},{"line":334,"address":[8791938],"length":1,"stats":{"Line":1}},{"line":335,"address":[8791953,8790679,8790981],"length":1,"stats":{"Line":1}},{"line":336,"address":[8792604,8792151,8792193,8792048,8790691,8792073,8792943,8790688],"length":1,"stats":{"Line":4}},{"line":338,"address":[8792116,8792240],"length":1,"stats":{"Line":2}},{"line":339,"address":[8792277,8792352],"length":1,"stats":{"Line":2}},{"line":341,"address":[8792760,8792803,8792561],"length":1,"stats":{"Line":3}},{"line":342,"address":[8792453],"length":1,"stats":{"Line":1}},{"line":343,"address":[8857511],"length":1,"stats":{"Line":4}},{"line":344,"address":[8792835],"length":1,"stats":{"Line":1}},{"line":345,"address":[8790698,8792316,8792901],"length":1,"stats":{"Line":2}},{"line":347,"address":[8790462,8790363,8790505,8790009,8789919,8790430],"length":1,"stats":{"Line":5}},{"line":348,"address":[8789832,8790167,8790245],"length":1,"stats":{"Line":2}},{"line":353,"address":[8818759,8818723,8818237,8818665,8818135,8818858,8819049,8819023,8818640],"length":1,"stats":{"Line":5}},{"line":356,"address":[8818610,8818564,8818592,8818128,8818558],"length":1,"stats":{"Line":3}},{"line":359,"address":[8818360,8818826,8818268,8818716],"length":1,"stats":{"Line":4}},{"line":360,"address":[8819072],"length":1,"stats":{"Line":1}},{"line":361,"address":[8820096,8819128,8819272,8819376,8819088,8819237,8819203,8819075,8819252],"length":1,"stats":{"Line":5}},{"line":362,"address":[8819324,8819230,8819407,8819168],"length":1,"stats":{"Line":3}},{"line":364,"address":[8819664],"length":1,"stats":{"Line":1}},{"line":367,"address":[8819683],"length":1,"stats":{"Line":1}},{"line":368,"address":[8819774],"length":1,"stats":{"Line":1}},{"line":369,"address":[8819804],"length":1,"stats":{"Line":1}},{"line":370,"address":[8819845],"length":1,"stats":{"Line":1}},{"line":371,"address":[8820107,8819890,8819242],"length":1,"stats":{"Line":2}},{"line":372,"address":[8820301],"length":1,"stats":{"Line":1}},{"line":374,"address":[8821904,8850572,8850586,8850377,8850352,8850416,8850525,8778512,8833520,8847382,8778565,8847296,8847360,8850600,8833607,8847321,8850300,8821915,8850288],"length":1,"stats":{"Line":12}},{"line":376,"address":[8833567,8778546,8850466],"length":1,"stats":{"Line":2}},{"line":379,"address":[8833595,8833551,8850497],"length":1,"stats":{"Line":2}},{"line":380,"address":[8778553,8833543,8850544],"length":1,"stats":{"Line":2}},{"line":383,"address":[8820353],"length":1,"stats":{"Line":1}},{"line":384,"address":[8820678,8820721,8820507,8820385],"length":1,"stats":{"Line":4}},{"line":385,"address":[8820417],"length":1,"stats":{"Line":1}},{"line":386,"address":[8820534,8819257,8820495,8820710,8820555],"length":1,"stats":{"Line":4}},{"line":387,"address":[8820769,8822016,8822000],"length":1,"stats":{"Line":3}},{"line":388,"address":[8820792],"length":1,"stats":{"Line":1}},{"line":390,"address":[8821104,8820949],"length":1,"stats":{"Line":1}},{"line":391,"address":[8820986,8820840],"length":1,"stats":{"Line":2}},{"line":392,"address":[8821049],"length":1,"stats":{"Line":1}},{"line":393,"address":[8821013],"length":1,"stats":{"Line":1}},{"line":398,"address":[8821265,8820444,8820799,8820317,8819738],"length":1,"stats":{"Line":1}},{"line":399,"address":[8819079],"length":1,"stats":{"Line":1}},{"line":400,"address":[8821897,8821385,8819059,8821589,8819056,8821455,8821491,8821360],"length":1,"stats":{"Line":4}},{"line":401,"address":[8821779,8821558,8821740,8821428],"length":1,"stats":{"Line":4}},{"line":402,"address":[8821546,8821578,8821620,8821772,8821479],"length":1,"stats":{"Line":4}},{"line":403,"address":[8821811],"length":1,"stats":{"Line":1}},{"line":404,"address":[8819066,8821871],"length":1,"stats":{"Line":2}},{"line":406,"address":[8818379,8818846,8818889,8818747,8818287,8818814],"length":1,"stats":{"Line":5}},{"line":407,"address":[8818537,8818200,8818629],"length":1,"stats":{"Line":2}},{"line":413,"address":[8779296,8778893,8779415,8779705,8779514,8778791,8779379,8779679,8779321],"length":1,"stats":{"Line":5}},{"line":416,"address":[8778784,8779214,8779248,8779266,8779220],"length":1,"stats":{"Line":3}},{"line":419,"address":[8778924,8779482,8779372,8779016],"length":1,"stats":{"Line":4}},{"line":420,"address":[8780288,8781256,8779712,8780403,8780472,8780452,8780437,8779715,8780328,8780576],"length":1,"stats":{"Line":6}},{"line":421,"address":[8780607,8780368,8780430,8780524],"length":1,"stats":{"Line":3}},{"line":423,"address":[8780864],"length":1,"stats":{"Line":1}},{"line":426,"address":[8780883],"length":1,"stats":{"Line":1}},{"line":427,"address":[8780974],"length":1,"stats":{"Line":1}},{"line":428,"address":[8781004],"length":1,"stats":{"Line":1}},{"line":429,"address":[8855681],"length":1,"stats":{"Line":2}},{"line":430,"address":[8781461],"length":1,"stats":{"Line":1}},{"line":432,"address":[8835724,8777658,8833718,8835949,8777496,8777600,8835776,8835840,8833657,8835963,8777456,8835712,8835977,8782496,8835801,8833696,8782507,8833632],"length":1,"stats":{"Line":11}},{"line":434,"address":[8777631,8777647,8835890],"length":1,"stats":{"Line":2}},{"line":435,"address":[8777623,8835921,8777484],"length":1,"stats":{"Line":2}},{"line":438,"address":[8781513],"length":1,"stats":{"Line":1}},{"line":439,"address":[8781545,8781838,8781667,8781881],"length":1,"stats":{"Line":4}},{"line":440,"address":[8781577],"length":1,"stats":{"Line":1}},{"line":441,"address":[8780457,8781694,8781870,8781715,8781655],"length":1,"stats":{"Line":4}},{"line":442,"address":[8782592,8782608,8781929],"length":1,"stats":{"Line":3}},{"line":443,"address":[8781952],"length":1,"stats":{"Line":1}},{"line":445,"address":[8782109,8782252],"length":1,"stats":{"Line":1}},{"line":446,"address":[8782000,8782146],"length":1,"stats":{"Line":2}},{"line":447,"address":[8782209],"length":1,"stats":{"Line":1}},{"line":448,"address":[8782173],"length":1,"stats":{"Line":1}},{"line":452,"address":[8781604,8779719,8781959,8782413,8781477,8780938],"length":1,"stats":{"Line":2}},{"line":453,"address":[8779728,8779839,8779744,8779769,8779731,8779875,8779973,8780281],"length":1,"stats":{"Line":4}},{"line":454,"address":[8780004,8779812,8779930,8779863],"length":1,"stats":{"Line":3}},{"line":455,"address":[8779738,8780255],"length":1,"stats":{"Line":2}},{"line":457,"address":[8779035,8778943,8779403,8779545,8779470,8779502],"length":1,"stats":{"Line":5}},{"line":458,"address":[8778856,8779193,8779285],"length":1,"stats":{"Line":2}},{"line":464,"address":[8793543,8793449,8793642,8792967,8793507,8793807,8793833,8793424,8793069],"length":1,"stats":{"Line":5}},{"line":467,"address":[8793390,8793858,8793840,8793396,8792960],"length":1,"stats":{"Line":3}},{"line":470,"address":[8793192,8793500,8793610,8793100],"length":1,"stats":{"Line":4}},{"line":471,"address":[8794613,8793891,8794758,8794464,8794648,8793888,8794628,8794579,8794504,8795486],"length":1,"stats":{"Line":6}},{"line":472,"address":[8794703,8794789,8794606,8794544],"length":1,"stats":{"Line":3}},{"line":474,"address":[8795046],"length":1,"stats":{"Line":1}},{"line":477,"address":[8795065],"length":1,"stats":{"Line":1}},{"line":478,"address":[8795156],"length":1,"stats":{"Line":1}},{"line":479,"address":[8795186],"length":1,"stats":{"Line":1}},{"line":480,"address":[8795234],"length":1,"stats":{"Line":1}},{"line":481,"address":[8857697],"length":1,"stats":{"Line":2}},{"line":482,"address":[8795691],"length":1,"stats":{"Line":1}},{"line":484,"address":[8842742,8850028,8778272,8850042,8778304,8844256,8849952,8844154,8833427,8846944,8842681,8844263,8842656,8842790,8844224,8842720,8833408,8797099,8843311,8846956,8849913,8797088,8849888],"length":1,"stats":{"Line":10}},{"line":486,"address":[8833422,8850002,8778299],"length":1,"stats":{"Line":2}},{"line":489,"address":[8838454,8778192,8777864,8777824,8846720,8846907,8838368,8778250,8846745,8846921,8846893,8846784,8838393,8797003,8842540,8838432,8796992,8842528],"length":1,"stats":{"Line":11}},{"line":491,"address":[8846834,8778239,8778223],"length":1,"stats":{"Line":2}},{"line":492,"address":[8777852,8778215,8846865],"length":1,"stats":{"Line":2}},{"line":495,"address":[8795743],"length":1,"stats":{"Line":1}},{"line":496,"address":[8795945,8794633,8797258,8795775,8797184,8795885],"length":1,"stats":{"Line":4}},{"line":497,"address":[8797200],"length":1,"stats":{"Line":1}},{"line":498,"address":[8796166,8797211],"length":1,"stats":{"Line":1}},{"line":499,"address":[8796182],"length":1,"stats":{"Line":1}},{"line":500,"address":[8796230],"length":1,"stats":{"Line":1}},{"line":502,"address":[8796376,8796453],"length":1,"stats":{"Line":2}},{"line":503,"address":[8796300],"length":1,"stats":{"Line":1}},{"line":504,"address":[8796421],"length":1,"stats":{"Line":1}},{"line":505,"address":[8796385],"length":1,"stats":{"Line":1}},{"line":508,"address":[8796736],"length":1,"stats":{"Line":1}},{"line":509,"address":[8796594],"length":1,"stats":{"Line":1}},{"line":510,"address":[8796693],"length":1,"stats":{"Line":1}},{"line":511,"address":[8796657],"length":1,"stats":{"Line":1}},{"line":515,"address":[8795834,8796189,8795120,8793895,8796886,8795707,8796339],"length":1,"stats":{"Line":2}},{"line":516,"address":[8793945,8794015,8794457,8794051,8793904,8793920,8793907,8794149],"length":1,"stats":{"Line":4}},{"line":517,"address":[8794106,8793988,8794180,8794039],"length":1,"stats":{"Line":3}},{"line":518,"address":[8793914,8794431],"length":1,"stats":{"Line":2}},{"line":520,"address":[8793119,8793531,8793598,8793630,8793211,8793673],"length":1,"stats":{"Line":5}},{"line":521,"address":[8793032,8793369,8793877],"length":1,"stats":{"Line":2}},{"line":528,"address":[8783177,8783152,8782695,8782797,8783535,8783561,8783235,8783271,8783370],"length":1,"stats":{"Line":5}},{"line":530,"address":[8783124,8783586,8782688,8783118,8783568],"length":1,"stats":{"Line":3}},{"line":533,"address":[8783228,8782828,8782920,8783338],"length":1,"stats":{"Line":4}},{"line":534,"address":[8783635,8784436,8783632,8784456,8784354,8784421,8784575,8785729,8784247,8784391,8784192,8784406],"length":1,"stats":{"Line":8}},{"line":535,"address":[8784514,8784606,8784381,8784295],"length":1,"stats":{"Line":3}},{"line":537,"address":[8784872],"length":1,"stats":{"Line":1}},{"line":539,"address":[8784895],"length":1,"stats":{"Line":1}},{"line":540,"address":[8784997],"length":1,"stats":{"Line":1}},{"line":541,"address":[8785027],"length":1,"stats":{"Line":1}},{"line":542,"address":[8785217],"length":1,"stats":{"Line":1}},{"line":543,"address":[8785080],"length":1,"stats":{"Line":1}},{"line":544,"address":[8785182],"length":1,"stats":{"Line":1}},{"line":545,"address":[8785224],"length":1,"stats":{"Line":1}},{"line":546,"address":[8785406],"length":1,"stats":{"Line":1}},{"line":547,"address":[8785269],"length":1,"stats":{"Line":1}},{"line":548,"address":[8785371],"length":1,"stats":{"Line":1}},{"line":549,"address":[8785413],"length":1,"stats":{"Line":1}},{"line":551,"address":[8784396,8785740,8785458,8785668],"length":1,"stats":{"Line":3}},{"line":552,"address":[8784411,8785942,8786137,8786203],"length":1,"stats":{"Line":3}},{"line":553,"address":[8786605,8786671,8784426,8786406],"length":1,"stats":{"Line":3}},{"line":555,"address":[8787920,8836064,8838317,8777720,8836000,8836025,8838092,8836086,8838144,8838169,8787931,8838331,8778026,8777968,8777680,8838345,8838208,8838080],"length":1,"stats":{"Line":9}},{"line":557,"address":[8838258,8777999,8778015],"length":1,"stats":{"Line":1}},{"line":558,"address":[8838289,8777708,8777991],"length":1,"stats":{"Line":1}},{"line":561,"address":[8786869],"length":1,"stats":{"Line":1}},{"line":562,"address":[8787248,8786942,8787294,8787065],"length":1,"stats":{"Line":4}},{"line":563,"address":[8786978],"length":1,"stats":{"Line":1}},{"line":564,"address":[8787119,8784441,8787095,8787053,8787280],"length":1,"stats":{"Line":4}},{"line":565,"address":[8788016,8788032,8787342],"length":1,"stats":{"Line":3}},{"line":566,"address":[8787365],"length":1,"stats":{"Line":1}},{"line":567,"address":[8787413],"length":1,"stats":{"Line":1}},{"line":568,"address":[8785612,8784950,8785135,8786901,8785324,8783642,8787005,8787372,8787703,8786089,8786553],"length":1,"stats":{"Line":2}},{"line":569,"address":[8783619,8783877,8783779,8784185,8783648,8783673,8783743,8783616],"length":1,"stats":{"Line":4}},{"line":570,"address":[8783908,8783716,8783767,8783834],"length":1,"stats":{"Line":3}},{"line":571,"address":[8783626,8784159],"length":1,"stats":{"Line":2}},{"line":573,"address":[8783259,8783358,8782939,8782847,8783326,8783401],"length":1,"stats":{"Line":5}},{"line":574,"address":[8782760,8783097,8783605],"length":1,"stats":{"Line":2}},{"line":579,"address":[8798153,8797389,8798127,8797769,8797863,8797287,8797962,8797744,8797827],"length":1,"stats":{"Line":5}},{"line":582,"address":[8797280,8797710,8797716,8798160,8798178],"length":1,"stats":{"Line":3}},{"line":585,"address":[8797420,8797512,8797930,8797820],"length":1,"stats":{"Line":4}},{"line":586,"address":[8798580,8798383,8798211,8798435,8798208,8798450,8799524,8798240,8798470,8798420,8798295],"length":1,"stats":{"Line":7}},{"line":587,"address":[8798525,8798340,8798410,8798611],"length":1,"stats":{"Line":3}},{"line":589,"address":[8844640,8833440,8847232,8802400,8850251,8844726,8850089,8850237,8850265,8844704,8850128,8778368,8847244,8802411,8844665,8850064,8833498,8778408],"length":1,"stats":{"Line":11}},{"line":591,"address":[8833487,8850178,8833471],"length":1,"stats":{"Line":2}},{"line":592,"address":[8778396,8833463,8850209],"length":1,"stats":{"Line":2}},{"line":595,"address":[8802304,8778762,8847209,8847008,8847033,8840512,8847195,8840473,8778048,8847072,8847181,8778088,8802315,8840534,8842592,8840448,8778704,8842604],"length":1,"stats":{"Line":11}},{"line":597,"address":[8847122,8778735,8778751],"length":1,"stats":{"Line":2}},{"line":598,"address":[8778727,8847153,8778076],"length":1,"stats":{"Line":2}},{"line":601,"address":[8798880],"length":1,"stats":{"Line":1}},{"line":603,"address":[8798903],"length":1,"stats":{"Line":1}},{"line":604,"address":[8799002],"length":1,"stats":{"Line":1}},{"line":605,"address":[8799032],"length":1,"stats":{"Line":1}},{"line":606,"address":[8799213],"length":1,"stats":{"Line":1}},{"line":607,"address":[8799082],"length":1,"stats":{"Line":1}},{"line":608,"address":[8799178],"length":1,"stats":{"Line":1}},{"line":609,"address":[8799217],"length":1,"stats":{"Line":1}},{"line":611,"address":[8798425,8799463,8799259,8799535],"length":1,"stats":{"Line":3}},{"line":612,"address":[8799932,8798440,8799995,8799740],"length":1,"stats":{"Line":3}},{"line":613,"address":[8800192],"length":1,"stats":{"Line":1}},{"line":614,"address":[8800245],"length":1,"stats":{"Line":1}},{"line":616,"address":[8800261,8800424,8800604,8800647],"length":1,"stats":{"Line":4}},{"line":617,"address":[8800369],"length":1,"stats":{"Line":1}},{"line":618,"address":[8800329,8800270],"length":1,"stats":{"Line":2}},{"line":620,"address":[8798455,8800472,8800636,8800451,8800412],"length":1,"stats":{"Line":4}},{"line":621,"address":[8803210,8802496,8800695,8803218],"length":1,"stats":{"Line":2}},{"line":622,"address":[8803216,8802523,8802581],"length":1,"stats":{"Line":2}},{"line":623,"address":[8802826,8802766],"length":1,"stats":{"Line":2}},{"line":625,"address":[8803008],"length":1,"stats":{"Line":1}},{"line":626,"address":[8800702,8802535,8803166,8802778],"length":1,"stats":{"Line":2}},{"line":627,"address":[8800718],"length":1,"stats":{"Line":1}},{"line":629,"address":[8800766],"length":1,"stats":{"Line":1}},{"line":630,"address":[8801098],"length":1,"stats":{"Line":1}},{"line":631,"address":[8800992,8800916],"length":1,"stats":{"Line":2}},{"line":632,"address":[8801055],"length":1,"stats":{"Line":1}},{"line":633,"address":[8801019],"length":1,"stats":{"Line":1}},{"line":637,"address":[8801381],"length":1,"stats":{"Line":1}},{"line":638,"address":[8801239],"length":1,"stats":{"Line":1}},{"line":639,"address":[8801338],"length":1,"stats":{"Line":1}},{"line":640,"address":[8801302],"length":1,"stats":{"Line":1}},{"line":644,"address":[8801531,8799410,8800204,8800725,8799137,8800297,8799884,8800955,8798215,8798958],"length":1,"stats":{"Line":2}},{"line":645,"address":[8798224,8798227,8801785,8801989,8801760,8801891,8801855,8802297],"length":1,"stats":{"Line":4}},{"line":646,"address":[8801879,8802020,8801946,8801828],"length":1,"stats":{"Line":3}},{"line":647,"address":[8802271,8798234],"length":1,"stats":{"Line":2}},{"line":649,"address":[8797439,8797531,8797918,8797993,8797950,8797851],"length":1,"stats":{"Line":5}},{"line":650,"address":[8798197,8797689,8797352],"length":1,"stats":{"Line":2}},{"line":655,"address":[8804400,8803680,8803239,8803705,8804426,8803814,8803772,8804018,8803341],"length":1,"stats":{"Line":5}},{"line":658,"address":[8804432,8803232,8803660,8803666,8804450],"length":1,"stats":{"Line":3}},{"line":659,"address":[8803753],"length":1,"stats":{"Line":1}},{"line":660,"address":[8804178,8803978],"length":1,"stats":{"Line":2}},{"line":661,"address":[8803926,8803856],"length":1,"stats":{"Line":2}},{"line":662,"address":[8804236,8803966,8804002,8804049,8803799],"length":1,"stats":{"Line":3}},{"line":663,"address":[8804310,8804359,8803372,8803462],"length":1,"stats":{"Line":2}},{"line":664,"address":[8804252,8804304],"length":1,"stats":{"Line":2}},{"line":666,"address":[8803481,8803391],"length":1,"stats":{"Line":2}},{"line":667,"address":[8803639,8804343,8804384,8803304,8804469,8804268,8803888],"length":1,"stats":{"Line":4}}],"covered":401,"coverable":416},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","tests","integration_tests_v2.rs"],"content":"extern crate influxdb;\n\n#[path = \"./utilities.rs\"]\nmod utilities;\nuse utilities::{assert_result_err, assert_result_ok, run_test};\n\nuse influxdb::{Client, Error, InfluxDbWriteable, ReadQuery, Timestamp};\n\n/// INTEGRATION TEST\n///\n/// This test case tests the Authentication\n#[tokio::test]\n#[cfg(not(tarpaulin))]\nasync fn test_authed_write_and_read() {\n    run_test(\n        || async move {\n            let client = Client::new(\"http://127.0.0.1:2086\", \"mydb\").with_token(\"admintoken\");\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_field(\"temperature\", 82);\n            let write_result = client.query(&write_query).await;\n            assert_result_ok(&write_result);\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = client.query(read_query).await;\n            assert_result_ok(&read_result);\n            assert!(\n                !read_result.unwrap().contains(\"error\"),\n                \"Data contained a database error\"\n            );\n        },\n        || async move {\n            let client = Client::new(\"http://127.0.0.1:2086\", \"mydb\").with_token(\"admintoken\");\n            let read_query = ReadQuery::new(\"DROP MEASUREMENT \\\"weather\\\"\");\n            let read_result = client.query(read_query).await;\n            assert_result_ok(&read_result);\n            assert!(!read_result.unwrap().contains(\"error\"), \"Teardown failed\");\n        },\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests the Authentication\n#[tokio::test]\n#[cfg(not(tarpaulin))]\nasync fn test_wrong_authed_write_and_read() {\n    use http::StatusCode;\n\n    run_test(\n        || async move {\n            let client = Client::new(\"http://127.0.0.1:2086\", \"mydb\").with_token(\"falsetoken\");\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_field(\"temperature\", 82);\n            let write_result = client.query(&write_query).await;\n            assert_result_err(&write_result);\n            match write_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    write_result.unwrap_err()\n                ),\n            }\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = client.query(&read_query).await;\n            assert_result_err(&read_result);\n            match read_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    read_result.unwrap_err()\n                ),\n            }\n        },\n        || async move {},\n    )\n    .await;\n}\n\n/// INTEGRATION TEST\n///\n/// This test case tests the Authentication\n#[tokio::test]\n#[cfg(not(tarpaulin))]\nasync fn test_non_authed_write_and_read() {\n    use http::StatusCode;\n\n    run_test(\n        || async move {\n            let non_authed_client = Client::new(\"http://127.0.0.1:2086\", \"mydb\");\n            let write_query = Timestamp::Hours(11)\n                .try_into_query(\"weather\")\n                .unwrap()\n                .add_field(\"temperature\", 82);\n            let write_result = non_authed_client.query(&write_query).await;\n            assert_result_err(&write_result);\n            match write_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    write_result.unwrap_err()\n                ),\n            }\n\n            let read_query = ReadQuery::new(\"SELECT * FROM weather\");\n            let read_result = non_authed_client.query(&read_query).await;\n            assert_result_err(&read_result);\n            match read_result {\n                Err(Error::ApiError(code)) if code == StatusCode::UNAUTHORIZED.as_u16() => {}\n                _ => panic!(\n                    \"Should be an ApiError(UNAUTHORIZED): {}\",\n                    read_result.unwrap_err()\n                ),\n            }\n        },\n        || async move {},\n    )\n    .await;\n}\n","traces":[{"line":1,"address":[389792],"length":1,"stats":{"Line":1}}],"covered":1,"coverable":1},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb","tests","utilities.rs"],"content":"use futures_util::FutureExt;\nuse influxdb::{Client, Error, ReadQuery};\nuse std::future::Future;\nuse std::panic::{AssertUnwindSafe, UnwindSafe};\n\n#[allow(dead_code)]\n#[cfg(not(tarpaulin_include))]\npub fn assert_result_err<A: std::fmt::Debug, B: std::fmt::Debug>(result: &Result<A, B>) {\n    result.as_ref().expect_err(\"assert_result_err failed\");\n}\n\n#[cfg(not(tarpaulin_include))]\npub fn assert_result_ok<A: std::fmt::Debug, B: std::fmt::Debug>(result: &Result<A, B>) {\n    result.as_ref().expect(\"assert_result_ok failed\");\n}\n\n#[allow(dead_code)]\n#[cfg(not(tarpaulin_include))]\npub fn create_client<T>(db_name: T) -> Client\nwhere\n    T: Into<String>,\n{\n    Client::new(\"http://127.0.0.1:8086\", db_name)\n}\n\n#[allow(dead_code)]\n#[cfg(not(tarpaulin_include))]\npub async fn create_db<T>(name: T) -> Result<String, Error>\nwhere\n    T: Into<String>,\n{\n    let test_name = name.into();\n    let query = format!(\"CREATE DATABASE {test_name}\");\n    create_client(test_name).query(ReadQuery::new(query)).await\n}\n\n#[allow(dead_code)]\n#[cfg(not(tarpaulin_include))]\npub async fn delete_db<T>(name: T) -> Result<String, Error>\nwhere\n    T: Into<String>,\n{\n    let test_name = name.into();\n    let query = format!(\"DROP DATABASE {test_name}\");\n    create_client(test_name).query(ReadQuery::new(query)).await\n}\n\n#[cfg(not(tarpaulin_include))]\npub async fn run_test<F, T, Fut1, Fut2>(test_fn: F, teardown: T)\nwhere\n    F: FnOnce() -> Fut1 + UnwindSafe,\n    T: FnOnce() -> Fut2,\n    Fut1: Future,\n    Fut2: Future,\n{\n    let test_result = AssertUnwindSafe(test_fn()).catch_unwind().await;\n    AssertUnwindSafe(teardown())\n        .catch_unwind()\n        .await\n        .expect(\"failed teardown\");\n    test_result.expect(\"failed test\");\n}\n","traces":[{"line":1,"address":[390064],"length":1,"stats":{"Line":1}},{"line":8,"address":[9017888,9017936],"length":1,"stats":{"Line":2}},{"line":9,"address":[9017941,9017893],"length":1,"stats":{"Line":2}},{"line":10,"address":[9017976,9017928],"length":1,"stats":{"Line":2}},{"line":13,"address":[8782912,8782960],"length":1,"stats":{"Line":11}},{"line":14,"address":[8782917,8782965],"length":1,"stats":{"Line":11}},{"line":15,"address":[8782952,8783000],"length":1,"stats":{"Line":10}},{"line":19,"address":[8782768,8782848],"length":1,"stats":{"Line":6}},{"line":23,"address":[8782780,8782875],"length":1,"stats":{"Line":6}},{"line":24,"address":[8782833,8782896],"length":1,"stats":{"Line":5}},{"line":28,"address":[9030035,9029920],"length":1,"stats":{"Line":5}},{"line":31,"address":[9029933,9030633,9030080,9029952,9029987,9030122],"length":1,"stats":{"Line":9}},{"line":32,"address":[8785290],"length":1,"stats":{"Line":3}},{"line":33,"address":[8785401,8785474],"length":1,"stats":{"Line":6}},{"line":34,"address":[9030107,9030555,9030342,9030670,9030431],"length":1,"stats":{"Line":9}},{"line":35,"address":[8807371,8807336],"length":1,"stats":{"Line":6}},{"line":39,"address":[8786291,8786176],"length":1,"stats":{"Line":4}},{"line":42,"address":[8786889,8786208,8786378,8786336,8786189,8786243],"length":1,"stats":{"Line":6}},{"line":43,"address":[8786314],"length":1,"stats":{"Line":2}},{"line":44,"address":[8786425,8786498],"length":1,"stats":{"Line":4}},{"line":45,"address":[8807492],"length":1,"stats":{"Line":8}},{"line":46,"address":[8854411,8854376],"length":1,"stats":{"Line":4}},{"line":49,"address":[9020401,9018064,9018080,9018257,9022548,9023605,9026805,9018000,9018032,9027873,9018128,9018144,9018016,9028945,9017984,9018112,9021473,9018048,9024673,9025748,9019332,9018096],"length":1,"stats":{"Line":26}},{"line":55,"address":[8784208,8783189,8783152,8784096,8785127,8783080,8783755,8784245,8784426,8783027,8783370,8784071,8784136,8784811,8783011,8783040],"length":1,"stats":{"Line":52}},{"line":56,"address":[8784235,8783179,8784457,8784201,8783145,8783283,8783401,8784339],"length":1,"stats":{"Line":39}},{"line":57,"address":[9022222,9023085,9019775,9026191,9025210,9026285,9027248,9027554,9020938,9022991,9028316,9028622,9024354,9023297,9024192,9018844,9025116,9018700,9020081,9021150,9027392,9025422,9026497,9019919,9019869,9020844,9024048,9028410,9022060,9022010,9029694,9023135,9026335,9018794,9029482,9021916,9029532,9027342,9020988,9028460,9029388,9019006,9025260,9024142],"length":1,"stats":{"Line":52}},{"line":58,"address":[8783677,8784733],"length":1,"stats":{"Line":13}},{"line":59,"address":[8811214,8810942],"length":1,"stats":{"Line":52}},{"line":60,"address":[8783935,8784991],"length":1,"stats":{"Line":13}},{"line":61,"address":[8785024,8783968],"length":1,"stats":{"Line":13}},{"line":62,"address":[8784648,8784088,8783592,8783031,8784012,8783209,8784265,8785068,8783015,8785144],"length":1,"stats":{"Line":26}}],"covered":31,"coverable":31},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb_derive","src","lib.rs"],"content":"use proc_macro::TokenStream;\n\nmod writeable;\nuse syn::parse_macro_input;\nuse writeable::expand_writeable;\n\n#[proc_macro_derive(InfluxDbWriteable, attributes(influxdb))]\npub fn derive_writeable(input: TokenStream) -> TokenStream {\n    expand_writeable(parse_macro_input!(input))\n        .unwrap_or_else(syn::Error::into_compile_error)\n        .into()\n}\n","traces":[{"line":8,"address":[957152,957469,957475],"length":1,"stats":{"Line":0}},{"line":9,"address":[957168,957381],"length":1,"stats":{"Line":0}},{"line":10,"address":[957326],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","runner","work","influxdb-rust","influxdb-rust","influxdb_derive","src","writeable.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse quote::{format_ident, quote};\nuse syn::parse::{Parse, ParseStream};\nuse syn::punctuated::Punctuated;\nuse syn::{\n    AngleBracketedGenericArguments, Data, DeriveInput, Field, Fields, GenericArgument, Ident,\n    Lifetime, Meta, PathArguments, PredicateType, Token, Type, TypeParamBound, WhereClause,\n    WherePredicate,\n};\nuse syn_path::type_path;\n\n#[derive(Debug)]\nstruct WriteableField {\n    ident: Ident,\n    ty: Type,\n    is_time: bool,\n    is_tag: bool,\n    is_ignore: bool,\n}\n\nmod kw {\n    use syn::custom_keyword;\n\n    custom_keyword!(time);\n    custom_keyword!(tag);\n    custom_keyword!(ignore);\n}\n\n#[allow(dead_code)] // TODO do we need to store the keywords?\nenum FieldAttr {\n    Time(kw::time),\n    Tag(kw::tag),\n    Ignore(kw::ignore),\n}\n\nimpl Parse for FieldAttr {\n    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {\n        let lookahead = input.lookahead1();\n        if lookahead.peek(kw::time) {\n            Ok(Self::Time(input.parse()?))\n        } else if lookahead.peek(kw::tag) {\n            Ok(Self::Tag(input.parse()?))\n        } else if lookahead.peek(kw::ignore) {\n            Ok(Self::Ignore(input.parse()?))\n        } else {\n            Err(lookahead.error())\n        }\n    }\n}\n\nstruct FieldAttrs(Punctuated<FieldAttr, Token![,]>);\n\nimpl Parse for FieldAttrs {\n    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {\n        Ok(Self(Punctuated::parse_terminated(input)?))\n    }\n}\n\nimpl TryFrom<Field> for WriteableField {\n    type Error = syn::Error;\n\n    fn try_from(field: Field) -> syn::Result<WriteableField> {\n        let Some(ident) = field.ident else {\n            return Err(syn::Error::new_spanned(\n                &field,\n                \"fields without ident are not supported\",\n            ));\n        };\n        let ty = field.ty;\n        let mut has_time_attr = false;\n        let mut is_tag = false;\n        let mut is_ignore = false;\n\n        for attr in field.attrs {\n            match attr.meta {\n                Meta::List(list) if list.path.is_ident(\"influxdb\") => {\n                    for attr in syn::parse2::<FieldAttrs>(list.tokens)?.0 {\n                        match attr {\n                            FieldAttr::Time(_) => has_time_attr = true,\n                            FieldAttr::Tag(_) => is_tag = true,\n                            FieldAttr::Ignore(_) => is_ignore = true,\n                        }\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        if [has_time_attr, is_tag, is_ignore]\n            .iter()\n            .filter(|&&b| b)\n            .count()\n            > 1\n        {\n            panic!(\"only one of time, tag, or ignore can be used\");\n        }\n\n        // A field is considered a time field if:\n        // 1. It has the #[influxdb(time)] attribute, OR\n        // 2. It's named \"time\" and doesn't have #[influxdb(ignore)]\n        let is_time = has_time_attr || (ident == \"time\" && !is_ignore);\n\n        Ok(WriteableField {\n            ident,\n            ty,\n            is_time,\n            is_tag,\n            is_ignore,\n        })\n    }\n}\n\npub fn expand_writeable(input: DeriveInput) -> syn::Result<TokenStream> {\n    let ident = input.ident;\n    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();\n\n    let fields = match input.data {\n        Data::Struct(strukt) => strukt.fields,\n        Data::Enum(inum) => {\n            return Err(syn::Error::new(\n                inum.enum_token.span,\n                \"#[derive(InfluxDbWriteable)] can only be used on structs\",\n            ))\n        }\n        Data::Union(cdu) => {\n            return Err(syn::Error::new(\n                cdu.union_token.span,\n                \"#[derive(InfluxDbWriteable)] can only be used on structs\",\n            ))\n        }\n    };\n\n    let writeable_fields: Vec<WriteableField> = match fields {\n        Fields::Named(fields) => fields\n            .named\n            .into_iter()\n            .map(WriteableField::try_from)\n            .collect::<syn::Result<Vec<_>>>()?,\n        _ => panic!(\"A struct without named fields is not supported!\"),\n    };\n\n    // Find the time field\n    let mut time_field = None;\n    let mut time_field_ty = None;\n    for wf in &writeable_fields {\n        if wf.is_time {\n            if time_field.is_some() {\n                panic!(\"multiple time fields found!\");\n            }\n            time_field = Some(wf.ident.clone());\n            time_field_ty = Some(wf.ty.clone());\n        }\n    }\n\n    // There must be exactly one time field\n    let time_field = time_field.expect(\"no time field found\");\n    let time_field_ty = time_field_ty.unwrap();\n\n    // Generate field assignments (excluding time and ignored fields)\n    let field_assignments = writeable_fields\n        .into_iter()\n        .filter_map(|wf| {\n            if wf.is_ignore || wf.is_time {\n                None\n            } else {\n                let ident = wf.ident;\n                Some(match wf.is_tag {\n                    true => quote!(query.add_tag(stringify!(#ident), self.#ident)),\n                    false => quote!(query.add_field(stringify!(#ident), self.#ident)),\n                })\n            }\n        })\n        .collect::<Vec<_>>();\n\n    // Add a necessary where clause\n    let mut where_clause = where_clause.cloned().unwrap_or(WhereClause {\n        where_token: Default::default(),\n        predicates: Punctuated::new(),\n    });\n    let mut err_ty = type_path!(<::influxdb::Timestamp as ::core::convert::TryFrom>::Error);\n    err_ty\n        .path\n        .segments\n        .iter_mut()\n        .nth(err_ty.qself.as_ref().unwrap().position - 1)\n        .unwrap()\n        .arguments = PathArguments::AngleBracketed(AngleBracketedGenericArguments {\n        colon2_token: None,\n        lt_token: Default::default(),\n        args: [GenericArgument::Type(time_field_ty.clone())]\n            .into_iter()\n            .collect(),\n        gt_token: Default::default(),\n    });\n    where_clause\n        .predicates\n        .push(WherePredicate::Type(PredicateType {\n            lifetimes: None,\n            bounded_ty: Type::Path(err_ty),\n            colon_token: Default::default(),\n            bounds: [TypeParamBound::Lifetime(Lifetime {\n                apostrophe: Span::call_site(),\n                ident: format_ident!(\"static\"),\n            })]\n            .into_iter()\n            .collect(),\n        }));\n\n    // Assemble the rest of the code\n    Ok(quote! {\n        const _: () = {\n            mod __influxdb_private {\n                use ::influxdb::{InfluxDbWriteable, Timestamp};\n                use ::core::fmt::{self, Debug, Display, Formatter, Write as _};\n\n                pub enum Error<T>\n                where\n                    Timestamp: TryFrom<T>\n                {\n                    TimestampError(<Timestamp as TryFrom<T>>::Error),\n                    QueryError(<Timestamp as InfluxDbWriteable>::Error)\n                }\n\n                impl<T> Clone for Error<T>\n                where\n                    Timestamp: TryFrom<T>,\n                    <Timestamp as TryFrom<T>>::Error: Clone\n                {\n                    fn clone(&self) -> Self {\n                        match self {\n                            Self::TimestampError(err) => Self::TimestampError(err.clone()),\n                            Self::QueryError(err) => Self::QueryError(err.clone())\n                        }\n                    }\n                }\n\n                impl<T> Debug for Error<T>\n                where\n                    Timestamp: TryFrom<T>,\n                    <Timestamp as TryFrom<T>>::Error: Debug\n                {\n                    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n                        match self {\n                            Self::TimestampError(err) => f.debug_tuple(\"TimestampError\")\n                                .field(err)\n                                .finish(),\n                            Self::QueryError(err) => f.debug_tuple(\"QueryError\")\n                                .field(err)\n                                .finish()\n                        }\n                    }\n                }\n\n                impl<T> Display for Error<T>\n                where\n                    Timestamp: TryFrom<T>,\n                    <Timestamp as TryFrom<T>>::Error: Display\n                {\n                    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n                        match self {\n                            Self::TimestampError(err) => {\n                                write!(f, \"Unable to convert value to timestamp: {err}\")\n                            },\n                            Self::QueryError(err) => {\n                                write!(f, \"Unable to convert timestamp to query: {err}\")\n                            }\n                        }\n                    }\n                }\n\n                impl<T> ::std::error::Error for Error<T>\n                where\n                    Timestamp: TryFrom<T>,\n                    <Timestamp as TryFrom<T>>::Error: ::std::error::Error + 'static\n                {\n                    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {\n                        match self {\n                            Self::TimestampError(err) => Some(err),\n                            Self::QueryError(err) => Some(err)\n                        }\n                    }\n                }\n            }\n\n            impl #impl_generics ::influxdb::InfluxDbWriteable for #ident #ty_generics #where_clause {\n                type Error = __influxdb_private::Error<#time_field_ty>;\n\n                fn try_into_query<I: Into<String>>(\n                    self,\n                    name: I\n                ) -> ::core::result::Result<::influxdb::WriteQuery, Self::Error> {\n                    let timestamp: ::influxdb::Timestamp = self.#time_field\n                        .try_into()\n                        .map_err(__influxdb_private::Error::TimestampError)?;\n                    let mut query = timestamp.try_into_query(name)\n                        .map_err(__influxdb_private::Error::QueryError)?;\n                    #(\n                        query = #field_assignments;\n                    )*\n                    Ok(query)\n                }\n            }\n        };\n    })\n}\n","traces":[{"line":37,"address":[1005344,1006423,1006394],"length":1,"stats":{"Line":0}},{"line":38,"address":[1005374],"length":1,"stats":{"Line":0}},{"line":39,"address":[1006348,1005470,1005414],"length":1,"stats":{"Line":0}},{"line":40,"address":[1005505,1006389,1006180],"length":1,"stats":{"Line":0}},{"line":41,"address":[1005519,1006157,1005481],"length":1,"stats":{"Line":0}},{"line":42,"address":[1006162,1005554,1005980],"length":1,"stats":{"Line":0}},{"line":43,"address":[1005933,1005530,1005568],"length":1,"stats":{"Line":0}},{"line":44,"address":[1005674,1005756,1005938],"length":1,"stats":{"Line":0}},{"line":46,"address":[1005574,1005686],"length":1,"stats":{"Line":0}},{"line":54,"address":[1006432],"length":1,"stats":{"Line":0}},{"line":55,"address":[1006456],"length":1,"stats":{"Line":0}},{"line":62,"address":[974272,976330,976895],"length":1,"stats":{"Line":0}},{"line":63,"address":[974294],"length":1,"stats":{"Line":0}},{"line":64,"address":[976701,974528],"length":1,"stats":{"Line":0}},{"line":69,"address":[974399],"length":1,"stats":{"Line":0}},{"line":70,"address":[974434],"length":1,"stats":{"Line":0}},{"line":71,"address":[974442],"length":1,"stats":{"Line":0}},{"line":72,"address":[974450],"length":1,"stats":{"Line":0}},{"line":74,"address":[974730,976672,974458,974599],"length":1,"stats":{"Line":0}},{"line":75,"address":[974792],"length":1,"stats":{"Line":0}},{"line":76,"address":[975414,975569],"length":1,"stats":{"Line":0}},{"line":77,"address":[975679,976154,975794],"length":1,"stats":{"Line":0}},{"line":78,"address":[976234],"length":1,"stats":{"Line":0}},{"line":79,"address":[976291],"length":1,"stats":{"Line":0}},{"line":80,"address":[976304],"length":1,"stats":{"Line":0}},{"line":81,"address":[976317],"length":1,"stats":{"Line":0}},{"line":89,"address":[974980,974854],"length":1,"stats":{"Line":0}},{"line":90,"address":[974909],"length":1,"stats":{"Line":0}},{"line":91,"address":[974936,977008,977018],"length":1,"stats":{"Line":0}},{"line":92,"address":[974963],"length":1,"stats":{"Line":0}},{"line":101,"address":[975030,974986],"length":1,"stats":{"Line":0}},{"line":103,"address":[975215],"length":1,"stats":{"Line":0}},{"line":104,"address":[975108],"length":1,"stats":{"Line":0}},{"line":105,"address":[975156],"length":1,"stats":{"Line":0}},{"line":106,"address":[975182],"length":1,"stats":{"Line":0}},{"line":107,"address":[975193],"length":1,"stats":{"Line":0}},{"line":108,"address":[975204],"length":1,"stats":{"Line":0}},{"line":113,"address":[1002266,977040],"length":1,"stats":{"Line":0}},{"line":114,"address":[977101],"length":1,"stats":{"Line":0}},{"line":115,"address":[977227,977302],"length":1,"stats":{"Line":0}},{"line":117,"address":[977358],"length":1,"stats":{"Line":0}},{"line":118,"address":[977424],"length":1,"stats":{"Line":0}},{"line":119,"address":[977504],"length":1,"stats":{"Line":0}},{"line":120,"address":[1003206,977555],"length":1,"stats":{"Line":0}},{"line":121,"address":[977548],"length":1,"stats":{"Line":0}},{"line":125,"address":[977597],"length":1,"stats":{"Line":0}},{"line":126,"address":[977660,1003317],"length":1,"stats":{"Line":0}},{"line":127,"address":[977653],"length":1,"stats":{"Line":0}},{"line":133,"address":[977476],"length":1,"stats":{"Line":0}},{"line":134,"address":[977943,977694,978004],"length":1,"stats":{"Line":0}},{"line":137,"address":[977897],"length":1,"stats":{"Line":0}},{"line":143,"address":[978137],"length":1,"stats":{"Line":0}},{"line":144,"address":[978153],"length":1,"stats":{"Line":0}},{"line":145,"address":[978261,978181],"length":1,"stats":{"Line":0}},{"line":146,"address":[978371,1002916],"length":1,"stats":{"Line":0}},{"line":147,"address":[1002488],"length":1,"stats":{"Line":0}},{"line":150,"address":[1002517,1002571],"length":1,"stats":{"Line":0}},{"line":151,"address":[1002753],"length":1,"stats":{"Line":0}},{"line":156,"address":[978386],"length":1,"stats":{"Line":0}},{"line":157,"address":[978468],"length":1,"stats":{"Line":0}},{"line":160,"address":[978588],"length":1,"stats":{"Line":0}},{"line":162,"address":[978708,1003776,1004629,1005245],"length":1,"stats":{"Line":0}},{"line":163,"address":[1003861,1003805],"length":1,"stats":{"Line":0}},{"line":164,"address":[1003848],"length":1,"stats":{"Line":0}},{"line":166,"address":[1003870],"length":1,"stats":{"Line":0}},{"line":167,"address":[1003914,1004593],"length":1,"stats":{"Line":0}},{"line":168,"address":[1003942,1004635],"length":1,"stats":{"Line":0}},{"line":169,"address":[1004002,1003923],"length":1,"stats":{"Line":0}},{"line":176,"address":[978888,978754,978798],"length":1,"stats":{"Line":0}},{"line":177,"address":[978806],"length":1,"stats":{"Line":0}},{"line":178,"address":[978862],"length":1,"stats":{"Line":0}},{"line":180,"address":[978974,979039],"length":1,"stats":{"Line":0}},{"line":181,"address":[982447,982211],"length":1,"stats":{"Line":0}},{"line":184,"address":[982116],"length":1,"stats":{"Line":0}},{"line":185,"address":[982299,982227],"length":1,"stats":{"Line":0}},{"line":186,"address":[982413],"length":1,"stats":{"Line":0}},{"line":187,"address":[981936],"length":1,"stats":{"Line":0}},{"line":188,"address":[981586],"length":1,"stats":{"Line":0}},{"line":189,"address":[981597,981663],"length":1,"stats":{"Line":0}},{"line":190,"address":[981684],"length":1,"stats":{"Line":0}},{"line":191,"address":[981816],"length":1,"stats":{"Line":0}},{"line":192,"address":[981839],"length":1,"stats":{"Line":0}},{"line":193,"address":[981846,981915],"length":1,"stats":{"Line":0}},{"line":197,"address":[983354],"length":1,"stats":{"Line":0}},{"line":198,"address":[982619],"length":1,"stats":{"Line":0}},{"line":199,"address":[982627],"length":1,"stats":{"Line":0}},{"line":200,"address":[982870,982807],"length":1,"stats":{"Line":0}},{"line":201,"address":[983091],"length":1,"stats":{"Line":0}},{"line":202,"address":[982891],"length":1,"stats":{"Line":0}},{"line":203,"address":[982906,983066],"length":1,"stats":{"Line":0}},{"line":205,"address":[983324],"length":1,"stats":{"Line":0}},{"line":206,"address":[983347],"length":1,"stats":{"Line":0}},{"line":210,"address":[983601,1002285],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":93}],"coverage":77.57805108798486,"covered":820,"coverable":1057}